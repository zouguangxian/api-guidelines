# Microsoft REST API 指南

## 微软 REST API 指南工作组

姓名 | 姓名 | 姓名 |
---------------------------- | -------------------------------------- | ----------------------------------------
Dave Campbell (CTO C+E)      | Rick Rashid (CTO ASG)                  | John Shewchuk (Technical Fellow, TED HQ)
Mark Russinovich (CTO Azure) | Steve Lucco (Technical Fellow, DevDiv) | Murali Krishnaprasad (Azure App Plat)
Rob Howard (ASG)             | Peter Torr  (OSG)                      | Chris Mullins (ASG)

文档编辑： John Gossman (C+E), Chris Mullins (ASG), Gareth Jones (ASG), Rob Dolin (C+E), Mark Stafford (C+E)

# Microsoft REST API 指南

## 1. 摘要
作为设计原则，Microsoft REST API 指南鼓励应用程序开发人员通过 RESTful HTTP 接口访问资源。
为了在遵循 Microsoft REST API 指南的平台上为开发人员提供尽可能流畅的体验，REST API 应当遵循一致的设计指南，使其使用简单直观。

本文档建立了 Microsoft REST API 应当遵循的准则，以便一致地开发 RESTful 接口。

## 2. 目录
<!-- TOC depthFrom:2 depthTo:4 orderedList:false updateOnSave:false withLinks:true -->

- [Microsoft REST API 指南](#microsoft-rest-api-指南)
  - [微软 REST API 指南工作组](#微软-rest-api-指南工作组)
- [Microsoft REST API 指南](#microsoft-rest-api-指南-1)
  - [1. 摘要](#1-摘要)
  - [2. 目录](#2-目录)
  - [3. 引言](#3-引言)
    - [3.1. 推荐阅读](#31-推荐阅读)
  - [4. 解读指南](#4-解读指南)
    - [4.1. 指南的适用](#41-指南的适用)
    - [4.2. 现有服务和服务版本控制指南](#42-现有服务和服务版本控制指南)
    - [4.3. 需求语言](#43-需求语言)
    - [4.4. 许可](#44-许可)
  - [5. 分类](#5-分类)
    - [5.1. 错误](#51-错误)
    - [5.2. 故障](#52-故障)
    - [5.3. 延迟](#53-延迟)
    - [5.4. 完成时间](#54-完成时间)
    - [5.5. 长时间运行的 API 故障](#55-长时间运行的-api-故障)
  - [6. 客户端指导](#6-客户端指导)
    - [6.1. 忽略规则](#61-忽略规则)
    - [6.2. 可变顺序规则](#62-可变顺序规则)
    - [6.3. 静默失败规则](#63-静默失败规则)
  - [7. 一致性基础知识](#7-一致性基础知识)
    - [7.1. URL结构](#71-url结构)
    - [7.2. 网址长度](#72-网址长度)
    - [7.3. 规范标识符](#73-规范标识符)
    - [7.4. 支持的方法](#74-支持的方法)
      - [7.4.1. POST](#741-post)
      - [7.4.2. PATCH](#742-patch)
      - [7.4.3. 通过 PATCH 创建资源（UPSERT 语义）](#743-通过-patch-创建资源upsert-语义)
      - [7.4.4. OPTIONS 和 Link 请求头（等文档化方案出来后考虑？）](#744-options-和-link-请求头等文档化方案出来后考虑)
    - [7.5. 标准请求头](#75-标准请求头)
    - [7.6. 标准响应头](#76-标准响应头)
    - [7.7. 自定义 Headers](#77-自定义-headers)
    - [7.8. 指定请求头作为查询参数](#78-指定请求头作为查询参数)
    - [7.9. PII 参数](#79-pii-参数)
    - [7.10. 响应格式](#710-响应格式)
      - [7.10.1. 客户端指定的响应格式](#7101-客户端指定的响应格式)
      - [7.10.2. 错误条件响应](#7102-错误条件响应)
        - [ErrorResponse： 对象](#errorresponse-对象)
        - [Error ： 对象](#error--对象)
        - [InnerError ： 对象](#innererror--对象)
        - [例子](#例子)
    - [7.11. HTTP 状态码](#711-http-状态码)
    - [7.12. 可选的客户端库](#712-可选的客户端库)
  - [8. CORS](#8-cors)
    - [8.1. 客户指导](#81-客户指导)
      - [8.1.1. 避免预检](#811-避免预检)
    - [8.2. 服务指导](#82-服务指导)
  - [9. 集合](#9-集合)
    - [9.1. 项目键](#91-项目键)
    - [9.2. 序列化](#92-序列化)
    - [9.3. 集合 URL 模式](#93-集合-url-模式)
      - [9.3.1. 嵌套集合和属性](#931-嵌套集合和属性)
    - [9.4. 大集合](#94-大集合)
    - [9.5. 更改集合](#95-更改集合)
    - [9.6. 对集合进行排序](#96-对集合进行排序)
      - [9.6.1. 解释排序表达式](#961-解释排序表达式)
    - [9.7. 过滤](#97-过滤)
      - [9.7.1. 过滤器操作](#971-过滤器操作)
      - [9.7.2. 运算符示例](#972-运算符示例)
      - [9.7.3. 运算符优先级](#973-运算符优先级)
    - [9.8. 分页](#98-分页)
      - [9.8.1. 服务器驱动的分页](#981-服务器驱动的分页)
      - [9.8.2. 客户端驱动的分页](#982-客户端驱动的分页)
      - [9.8.3. 其他注意事项](#983-其他注意事项)
    - [9.9. 复合集合操作](#99-复合集合操作)
    - [9.10. 空结果](#910-空结果)
  - [10. 增量查询](#10-增量查询)
    - [10.1. 增量链接](#101-增量链接)
    - [10.2. 实体表示](#102-实体表示)
    - [10.3. 获取增量链路](#103-获取增量链路)
    - [10.4. 增量链路响应的内容](#104-增量链路响应的内容)
    - [10.5. 使用增量链路](#105-使用增量链路)
  - [11. JSON 标准化](#11-json-标准化)
    - [11.1. 基本类型的 JSON 格式标准化](#111-基本类型的-json-格式标准化)
    - [11.2. 日期和时间指南](#112-日期和时间指南)
      - [11.2.1. 生产日期](#1121-生产日期)
      - [11.2.2. 使用日期](#1122-使用日期)
      - [11.2.3. 兼容性](#1123-兼容性)
    - [11.3. 日期和时间的 JSON 序列化](#113-日期和时间的-json-序列化)
      - [11.3.1.  `DateLiteral` 格式](#1131--dateliteral-格式)
      - [11.3.2. 关于日期格式的说明](#1132-关于日期格式的说明)
    - [11.4. 持续时间](#114-持续时间)
    - [11.5. 间隔](#115-间隔)
    - [11.6. 重复间隔](#116-重复间隔)
  - [12. 版本控制](#12-版本控制)
    - [12.1. 版本控制格式](#121-版本控制格式)
      - [12.1.1. 组版本](#1211-组版本)
        - [组版本示例](#组版本示例)
    - [12.2. 何时实施版本](#122-何时实施版本)
    - [12.3. 重大变更的定义](#123-重大变更的定义)
  - [13. 长时间运行操作](#13-长时间运行操作)
    - [13.1. 基于资源的长时间运行操作 （RELO）](#131-基于资源的长时间运行操作-relo)
    - [13.2. 逐步长时间运行操作](#132-逐步长时间运行操作)
      - [13.2.1. PUT](#1321-put)
      - [13.2.2. POST](#1322-post)
      - [13.2.3. POST，混合模型](#1323-post混合模型)
      - [13.2.4. 操作资源](#1324-操作资源)
      - [13.2.5. operation 资源](#1325-operation-资源)
        - [完成百分比](#完成百分比)
        - [目标资源位置](#目标资源位置)
      - [13.2.6. 墓碑操作](#1326-墓碑操作)
      - [13.2.7. 典型流程，轮询](#1327-典型流程轮询)
        - [典型流程示例，轮询](#典型流程示例轮询)
      - [13.2.8. 典型流程，推送通知](#1328-典型流程推送通知)
        - [典型流程示例，推送通知现有订阅](#典型流程示例推送通知现有订阅)
      - [13.2.9. 重试](#1329-重试)
    - [13.3. 操作结果的保留策略](#133-操作结果的保留策略)
  - [14. 限流、配额和限制](#14-限流配额和限制)
    - [14.1. 原则](#141-原则)
    - [14.2. 返回代码（429 与 503）](#142-返回代码429-与-503)
    - [14.3. Retry-After 和 RateLimit 标头](#143-retry-after-和-ratelimit-标头)
    - [14.4. 服务指南](#144-服务指南)
      - [14.4.1. 响应能力](#1441-响应能力)
      - [14.4.2. 速率限制和配额](#1442-速率限制和配额)
      - [14.4.3. 过载的服务](#1443-过载的服务)
      - [14.4.4. 示例响应](#1444-示例响应)
    - [14.5. 调用者指南](#145-调用者指南)
    - [14.6. 处理忽略Retry-After标头的调用者](#146-处理忽略retry-after标头的调用者)
  - [15.通过webook推送通知](#15通过webook推送通知)
    - [15.1. 范围](#151-范围)
    - [15.2. 原则](#152-原则)
    - [15.3. 订阅类型](#153-订阅类型)
    - [15.4. 调用序列](#154-调用序列)
    - [15.5. 验证订阅](#155-验证订阅)
    - [15.6. 接收通知](#156-接收通知)
      - [15.6.1. 通知载荷](#1561-通知载荷)
    - [15.7. 以编程方式管理订阅](#157-以编程方式管理订阅)
      - [15.7.1. 创建订阅](#1571-创建订阅)
      - [15.7.2. 更新订阅](#1572-更新订阅)
      - [15.7.3. 删除订阅](#1573-删除订阅)
      - [15.7.4. 枚举订阅](#1574-枚举订阅)
    - [15.8. 安全](#158-安全)
  - [16. 不支持的请求](#16-不支持的请求)
    - [16.1. 基本指南](#161-基本指南)
    - [16.2. 功能允许列表](#162-功能允许列表)
      - [16.2.1. 错误响应](#1621-错误响应)
  - [17. 命名准则](#17-命名准则)
    - [17.1. 方法](#171-方法)
    - [17.2. 大小写](#172-大小写)
    - [17.3. 要避免的名称](#173-要避免的名称)
    - [17.4. 形成混合名称](#174-形成混合名称)
    - [17.5. 身份属性](#175-身份属性)
    - [17.6. 日期和时间属性](#176-日期和时间属性)
    - [17.7. 名称属性](#177-名称属性)
    - [17.8. 集合和计数](#178-集合和计数)
    - [17.9. 常用属性名称](#179-常用属性名称)
  - [18. 附录](#18-附录)
    - [18.1. 序列图注释](#181-序列图注释)
      - [18.1.1. 推送通知，每个用户流](#1811-推送通知每个用户流)
      - [18.1.2. 推送通知、firehose 流](#1812-推送通知firehose-流)

<!-- /TOC -->

## 3. 引言
开发人员通过 HTTP 接口访问大多数 Microsoft Cloud Platform 资源。
尽管每个服务通常都提供特定于语言的框架来包装其 API，但它们的所有操作最终都归结为 HTTP 请求。
Microsoft 必须支持广泛的客户端和服务，并且不能依赖可用于每个开发环境的丰富框架。
因此，这些准则的目标是确保具有基本 HTTP 支持的任何客户端都可以轻松且一致地使用 Microsoft REST API。

为了向开发人员提供尽可能流畅的体验，让这些 API 遵循一致的设计准则非常重要，从而使它们容易和直观使用。
本文档确立了 Microsoft REST API 开发人员在开发此类 API 时应遵循的准则。

一致性的好处也累积起来;一致性允许团队利用通用代码、模式、文档和设计决策。

这些准则旨在实现以下目标：
- 为 Microsoft 的所有 API 端点定义一致的实践和模式。
- 尽可能地遵守整个行业中公认的 REST/HTTP 最佳实践。 [\*]
- 使所有应用程序开发人员都可以轻松地通过 REST 接口访问 Microsoft 服务。
- 允许服务开发人员利用其他服务的先前工作来实现、测试和记录一致定义的 REST 端点。
- 允许合作伙伴（例如，非 Microsoft 实体）将这些准则用于他们自己的 REST 端点 设计。

[\*] 注意：这些准则旨在与符合 REST 架构风格的服务保持一致，尽管它们不涉及或要求遵循 REST 约束的服务。
本文档中使用的术语"REST"是指符合 REST 精神的服务，而不是照本宣科的REST。

### 3.1. 推荐阅读
建议了解 REST 架构风格背后的理念，以开发良好的基于 HTTP 的服务。
如果您不熟悉RESTful设计，这里有一些很好的资源：

[维基百科上的REST][rest-on-wikipedia] -- REST背后的常见定义和核心思想概述。

[REST 学位论文][fielding] --Roy Fielding关于网络架构的论文"Architectural Styles and the Design of Network-based Software Architectures"中REST的章节

[RFC 7231][rfc-7231] -- 定义 HTTP/1.1 语义规范，并被视为权威资源。

[实践中的 REST][rest-in-practice] -- 关于 REST 基础知识的书。

## 4. 解读指南
### 4.1. 指南的适用
这些准则适用于 Microsoft 或任何合作伙伴服务公开的任何 REST API。
私有或内部 API 也应当尝试遵循这些准则，因为内部服务最终往往会对外公开。
一致性不仅对外部客户有价值，而且对内部服务使用者也很有价值，这些准则提供了对任何服务都有用的最佳实践。

有正当理由免除这些准则。
显然，实现或必须与某些外部定义的 REST API 进行互操作的 REST 服务必须与那些 API 兼容，而不必与这些准则兼容。
某些服务可能也有特殊的性能需求，需要不同的格式，例如二进制协议。

### 4.2. 现有服务和服务版本控制指南
我们不建议仅仅为了遵守该准则而对早于这些准则的服务进行重大更改。
当兼容性被破坏时，该服务应尝试在下一个版本发布时变得兼容。
当服务添加新的 API 时，该 API 应当与相同版本的其他 API 保持一致。
因此，如果服务是根据指南的 1.0 版编写的，则增量添加到服务中的新 API 也应遵循 1.0 版。然后，该服务可以升级以在服务的下一个主要版本中与最新版本的准则保持一致。

### 4.3. 需求语言
本文档中的关键字"必须"、"不得"、"必需"、"应当"、"不应当"、"应该"、"不应该"、"推荐"、"可以"和"可选"按[RFC 2119][rfc-2119]中所述进行解释。

### 4.4. 许可

本作品采用知识共享署名 4.0 国际许可协议进行许可。
要查看此许可证的副本，请访问 https://creativecommons.org/licenses/by/4.0/ 或致函Creative Commons, PO Box 1866, Mountain View, CA 94042, USA。

## 5. 分类
作为加入 Microsoft REST API 指南的一部分，服务必须符合下面定义的分类。

### 5.1. 错误
错误，或者更具体地说是服务错误，被定义为客户端将无效数据传递给服务，并且服务 _正确地_ 拒绝了该请求。
示例包括无效凭据、错误参数、未知版本ID或类似情况。
这些通常是"4xx"HTTP错误代码，是客户端传递不正确或无效数据的结果。

错误 _不会_ 影响 API 的整体可用性。

### 5.2. 故障
故障，或者更具体地说，服务故障被定义为服务未能正确返回以响应有效的客户端请求。
这些通常是"5xx"HTTP错误代码。

故障 _确实_ 会影响整体 API 可用性。

由于限流或配额而失败的调用不得计为故障。
由于服务快速失败请求（通常是为了保护其自身）而失败的调用算作故障。

### 5.3. 延迟
延迟定义为完成特定 API 调用所需的时间，尽可能接近客户端进行度量。
此指标以相同的方式适用于同步和异步 API。
对于长时间运行的调用，延迟是在初始请求上测量的，并测量该调用（而不是整体操作）完成所需的时间。

### 5.4. 完成时间
公开长时间操作的服务必须跟踪这些操作的"完成时间"指标。

### 5.5. 长时间运行的 API 故障
对于长时间运行的 API，操作的初始请求和检索结果的请求在技术上都可能正常运行（每个请求都传回 200），但底层的操作可能失败。
长时间运行的故障必须作为故障汇总到整体可用性指标中。

## 6. 客户端指导
为确保客户端与 REST 服务通信的最佳体验，客户端应遵循以下最佳实践：

### 6.1. 忽略规则
对于在调用之前不知道数据的确切情况的松散耦合的客户端，如果服务器返回客户端没有预料到的内容，则客户端必须安全地忽略它。

某些服务可能会在不更改版本号的情况下向响应添加字段。
这样做的服务必须在其文档中明确说明这一点，并且客户端必须忽略未知字段。

### 6.2. 可变顺序规则
客户端不得依赖于数据在 JSON 服务响应中出现的顺序。
例如，客户端应该对 JSON 对象中的字段重新排序具有适应力。
当服务支持时，客户端可以请求按特定顺序返回数据。
例如，服务可能支持使用 _$orderBy_ 查询字符串参数来指定 JSON 数组中元素的顺序。
服务也可以显式指定某些元素的顺序作为服务协定的一部分。
例如，服务可能始终返回 JSON 对象的"type"信息作为对象中的第一个字段，以简化客户端上的响应解析。
客户端可以依赖服务显式标识的排序行为。

### 6.3. 静默失败规则
客户端请求可选的服务器功能（如可选的请求头）时必须具有忽略该特定功能的适应力。

## 7. 一致性基础知识
### 7.1. URL结构
人类应该能够轻松阅读和构建URL。

这有助于发现并简化在没有良好支持的客户端库的平台上的采用。

结构良好的 URL 示例如下：

```
https://api.contoso.com/v1.0/people/jdoe@contoso.com/inbox
```

不友好的示例 URL 是：

```
https://api.contoso.com/EWS/OData/Users('jdoe@microsoft.com')/Folders('AAMkADdiYzI1MjUzLTk4MjQtNDQ1Yy05YjJkLWNlMzMzYmIzNTY0MwAuAAAAAACzMsPHYH6HQoSwfdpDx-2bAQCXhUk6PC1dS7AERFluCgBfAAABo58UAAA=')
```

经常出现的一种模式是使用 URL 作为值。
服务可能使用 URL 作为值。
例如，以下情况是可以接受的：

```
https://api.contoso.com/v1.0/items?url=https://resources.contoso.com/shoes/fancy
```

### 7.2. 网址长度
HTTP 1.1 消息格式定义在 RFC 7230 的 [3.1.1][rfc-7230-3-1-1] ，对包含目标 URL 的请求行没有长度限制。
来自 RFC：

> HTTP对请求行的长度没有预定的限制。[...] 当服务器接收的请求 URI 超出预期的长度时必须响应 414（URI Too Long）状态码。

可以生成超过 2,083 个字符的 URL 的服务必须为他们希望支持的客户端提供便利。
以下是确定目标客户端支持情况的一些来源：

**TODO**

* [https://stackoverflow.com/a/417184](https://stackoverflow.com/a/417184)
* [https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/](https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/)

另请注意，某些技术堆栈具有硬性且可调整的 URL 限制，因此在设计服务时请记住这一点。

### 7.3. 规范标识符
除了友好的 URL 之外，可以移动或重命名的资源还应公开包含唯一稳定标识符的 URL。
在与服务交互的过程中，从资源的友好名称中获取稳定的 URL 有可能是必要的，例如某些服务使用的"/my"快捷方式。

稳定标识符不需要是 GUID。

包含规范标识符的 URL 示例如下：

```
https://api.contoso.com/v1.0/people/7011042402/inbox
```

### 7.4. 支持的方法
操作必须尽可能使用正确的 HTTP 方法，并且必须遵守操作幂等性。
HTTP 方法通常称为 HTTP 动词。
这些术语在此上下文中是同义词，但是 HTTP 规范使用术语方法。

以下是 Microsoft REST 服务应支持的方法列表。
并非所有资源都支持所有方法，但使用以下方法的所有资源都必须符合其用法。

方法  | 描述                                                                                                                | 是否幂等
------- | -------------------------------------------------------------------------------------------------------------------------- | -------------
GET     | 返回对象的当前值                                                                                      | 真
PUT     | 替换对象或创建命名对象（如果适用）                                                               | 真
DELETE  | 删除对象                                                                                                           | 真
POST    | 根据提供的数据创建新对象，或提交命令                                                        | 假
HEAD    | 返回 GET 响应的对象的元数据。支持 GET 方法的资源也可能支持 HEAD 方法 | 真
PATCH   | 对对象应用部分更新                                                                                        | 假
OPTIONS | 获取有关请求的信息；有关详细信息，请参阅下文。                                                                    | 真

<small>表 1</small>

#### 7.4.1. POST 
POST 操作应支持 Location 响应头，以通过 Location 响应头指定任何未显式命名的已创建资源的位置。

例如，假设一个API服务的功能是创建服务器，该服务器将由该API服务命名：

```http
POST http://api.contoso.com/account1/servers
```

响应将如下所示：

```http
201 Created
Location: http://api.contoso.com/account1/servers/server321
```

其中"server321"是API服务分配的服务器名称。

服务还可以返回响应中已创建资源的完整元数据。

#### 7.4.2. PATCH
PATCH 已被 IETF 标准化为用于增量更新现有对象的方法（请参阅 [RFC 5789][rfc-5789]）。
符合Microsoft REST API 指南的 API 应支持 PATCH。

#### 7.4.3. 通过 PATCH 创建资源（UPSERT 语义）
允许调用者在创建时指定键值的服务应支持 UPSERT 语义，必须支持使用 PATCH 创建资源。
由于 PUT 被定义为内容的完全替换，因此客户端使用 PUT 修改数据是危险的。
在尝试更新资源时，不理解（因此忽略）资源属性的客户端不太可能在 PUT 上提供这些属性，因此可能会无意中删除此类属性。
服务可以选择性地支持 PUT 更新现有资源，但如果支持，则必须使用替换语义（即，在 PUT 之后，资源的属性必须与请求中提供的内容匹配，包括删除任何未提供的服务器属性）。

在 UPSERT 语义下， 服务器收到对不存在的资源的PATCH 调用将当做"创建"进行处理，而对现有资源的PATCH调用将当做"更新"进行处理。为了确保更新请求不被视为创建请求或反之亦然，客户端可以在请求中指定预设 HTTP 标头。
如果 PATCH 请求包含 If-Match 请求头，则该服务不得将该请求当做创建处理，如果该请求包含值为"*"的 If-None-Match 请求头，则不得将 PATCH 请求当做更新处理。

如果服务不支持 UPSERT，则对不存在的资源的 PATCH 调用必须返回 HTTP"409 Conflict"错误。

#### 7.4.4. OPTIONS 和 Link 请求头（等文档化方案出来后考虑？）
OPTIONS 允许客户端检索有关资源的信息，至少通过返回 Allow 请求头来表示此资源的有效方法。

此外，服务应包含一个 Link 头（请参阅 [RFC 5988][rfc-5988]），以指向相关资源的文档：

```http
Link: <{help}>; rel="help"
```

其中 {help} 是指向文档资源的 URL。

有关使用 OPTIONS 的示例，请参见 [预检 CORS 跨域调用][cors-preflight]。

### 7.5. 标准请求头
下面的请求头表应由 Microsoft REST API Guidelines 服务使用。
使用这些请求头不是强制性的，但如果使用它们，则必须一致地使用它们。

所有请求头值都必须遵循定义请求头字段的规范中规定的语法规则。
许多 HTTP 请求头定义在 [RFC7231][rfc-7231]，已批准请求头的完整列表可以在这里寻找： [IANA Header Registry][IANA-headers]。

请求头                            | 类型                                  | 描述
--------------------------------- | ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Authorization                     | String                                           | 请求的授权请求头
Date                              | Date                                             | 请求的时间戳，基于客户端的时钟，采用 [RFC 5322][rfc-5322-3-3] 日期和时间格式。 服务器不应对客户端时钟的准确性做出任何假设。 此标头可以包含在请求中，但在提供时必须采用此格式。 在提供日期时，必须将格林威治标准时间 (GMT) 用作此标头的时区参考。例如： `Wed, 24 Aug 2016 18:41:30 GMT`. 请注意，为此目的，GMT 完全等于 UTC（协调世界时）。
Accept                            | Content type                                     | 响应请求的内容类型，例如： <ul><li>application/xml</li><li>text/xml</li><li>application/json</li><li>text/javascript (for JSONP)</li></ul> 根据 HTTP 指南，这只是一个提示，响应可能具有不同的内容类型，例如 blob 提取，其中成功的响应将只是作为载荷的 blob 流。对于遵循 OData 的服务，应遵循 OData 中指定的首选项顺序。
Accept-Encoding                   | Gzip, deflate                                    | REST 端点 应支持 GZIP 和 DEFLATE 编码（如果适用）。对于非常大的资源，服务可能会忽略并返回未压缩的数据。
Accept-Language                   | "en", "es", etc.                                 | 指定响应的首选语言。服务不需要支持此操作，但如果服务支持本地化，则必须通过 Accept-Language 标头来支持。
Accept-Charset                    | 字符集类型，如"UTF-8"                        | 默认值为 UTF-8，但服务应该能够处理 ISO-8859-1。
Content-Type                      | Content type                                     | 请求正文的Mime类型（PUT/POST/PATCH）
Prefer                            | return=minimal, return=representation            | 如果指定了 return=minimal首选项，则服务应返回一个空正文以响应成功的插入或更新。如果指定了 return=representation，则服务应在响应中返回创建或更新的资源。如果存在客户端有时会从响应中受益的情况，则服务应支持此标头，但有时响应会对带宽造成太大影响。
If-Match, If-None-Match, If-Range | String                                           | 支持使用乐观并发控制对资源进行更新的服务必须支持 If-Match 标头才能执行此操作。服务还可以使用与 ETag 相关的其他标头，只要它们遵循 HTTP 规范。

### 7.6. 标准响应头
服务应返回以下响应头，除非在"必需"列中注明。

响应头    | 必填                                      | 描述
------------------ | --------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Date               | 所有响应                                 | 根据服务器的时钟处理响应的时间戳，以 [RFC 5322][rfc-5322-3-3] 日期和时间格式处理响应。 此标头必须包含在响应中。 格林威治标准时间 （GMT） 必须用作此标头的时区参考。 例如： `Wed, 24 Aug 2016 18:41:30 GMT`.请注意，为此目的，GMT 正好等于 UTC（协调世界时）。
Content-Type       | 所有响应                                 | 内容类型
Content-Encoding   | 所有响应                                 | GZIP 或DEFLATE（视情况而定）
Preference-Applied | 在请求中指定时                     | 是否应用了 Prefer 请求头中指示的首选项
ETag               | 当请求的资源具有实体标签时 | ETag 响应头字段为请求的变体提供实体标记的当前值。与 If-Match、If-None-Match 和 If-Range 一起使用，以实现乐观并发控制。

### 7.7. 自定义 Headers
给定API的基本操作不需要自定义Headers。

本文档中的一些准则规定了非标准 HTTP Headers的使用。
此外，某些服务可能需要添加额外的功能，这些功能通过 HTTP Headers公开。
以下准则有助于保持自定义标头使用之间的一致性。

非标准 HTTP 标头的标头必须具有以下两种格式之一：

1. 在 IANA 注册为"provisional"标头的通用格式 （[RFC 3864][rfc-3864]）
2. 一种作用域格式，用于对于注册来说过于特定于用法的标头

下面介绍了这两种格式。

### 7.8. 指定请求头作为查询参数
某些请求头对某些方案（如 AJAX 客户端）提出了挑战，尤其是在进行可能不支持添加请求头的跨域调用时。
因此，除了请求头之外，某些请求头也可以被接受为查询参数，其命名与请求头相同：

并非所有请求头都可用作查询参数，包括大多数标准 HTTP 请求头。

考虑何时接受请求头作为参数的条件是：

1. 任何自定义请求头也必须被接受为参数。
2. 所需的标准请求头可以被接受为参数。
3. 具有安全敏感性的必需请求头（例如，授权请求头）可能不适合作为参数；服务所有者应根据具体情况进行评估。

此规则的一个例外是 Accept 请求头。
通常的做法是使用具有简单名称的方案，而不是使用HTTP 规范中描述的 Accept 的完整功能。

### 7.9. PII 参数
根据组织的隐私政策，客户端不应在 URL 中传输个人身份信息 （PII） 参数（作为路径或查询字符串的一部分），因为此信息可能会通过客户端、网络和服务器日志以及其他机制无意中暴露。

因此，服务应接受作为请求头传输的 PII 参数。

但是，在许多情况下，由于客户端或软件限制，无法遵循上述建议。
为了解决这些限制，服务还应接受这些 PII 参数作为 URL 的一部分，以符合这些准则的其余部分。

接受 PII 参数（无论是在 URL 中还是作为请求头）的服务应符合其组织工程领导层指定的隐私策略。
这通常包括建议客户端首选请求头进行传输，并且实现遵循特殊的预防措施，以确保正确处理日志和其他服务数据收集。

### 7.10. 响应格式
为了使组织拥有一个成功的平台，他们必须以开发人员习惯使用的格式提供数据，并以一致的方式提供数据，使开发人员能够使用通用代码处理响应。

基于Web的通信，特别是当涉及移动或其他低带宽客户端时，由于各种原因，已经朝着JSON的方向迅速发展，包括它倾向于更轻量级和易于使用的基于JavaScript的客户端。

JSON 属性名称应采用驼峰式。

服务应提供 JSON 作为默认编码。

#### 7.10.1. 客户端指定的响应格式
在 HTTP 中，响应格式应由客户端使用 Accept 请求头请求。
这是一个提示，服务器可选择忽略它，即使这不是行为良好的服务器的典型特征。
客户端可以发送多个Accept请求头，服务可以选择其中之一。

默认响应格式（未提供Accept请求头）应为 application/json，并且所有服务都必须支持 application/json。

接受标头    | 响应类型                      | 笔记
---------------- | ---------------------------------- | -------------------------------------------
application/json | 载荷应以 JSON 格式返回 | 同时接受 JSONP 案例的text/javascript

```http
GET https://api.contoso.com/v1.0/products/user
Accept: application/json
```

#### 7.10.2. 错误条件响应
对于不成功的情况，开发人员应该能够编写一段代码，在不同的 Microsoft REST API 指南服务中一致地处理错误。
这允许构建简单可靠的基础架构，以将异常作为独立于成功响应的流来处理。
以下内容基于 OData v4 JSON 规范。
但是，它非常通用，不需要特定的 OData 构造。
API 应使用此格式，即使它们未使用其他 OData 构造。

错误响应必须是单个 JSON 对象。
此对象必须具有名为"error"的名称/值对。该值必须是 JSON 对象。

此对象必须包含名称为"code"和"message"的名称/值对，并且它可能包含名称为"target"、"details"和"innererror"的名称/值对。

"code"名称/值对的值是与语言无关的字符串。
它的值是服务定义的错误代码，应该是人类可读的。
此代码用作比响应中指定的 HTTP 错误代码更具体的错误指示符。
服务应该有相对较少的数量（大约20个）的"code"的可能值，并且所有客户端都必须能够处理所有这些值。
大多数服务将需要更多更具体的错误代码，并非所有客户端都对此感兴趣。
这些错误代码应公开在"innererror"名称/值对中，如下所述。
为现有客户端可见的"code"引入新值是一项重大更改，需要增加版本。
服务可以通过向"innererror"添加新的错误代码来避免不兼容的更改。

"message"名称/值对的值必须是错误信息的人类可读的表示形式。
它旨在作为开发人员的辅助工具，不适合向最终用户公开。
希望向最终用户公开合适消息的服务必须通过 [annotation][odata-json-annotations] 或自定义属性。
服务不应为最终用户本地化"message"，因为这样做可能会使可能正在记录该值的应用开发人员无法读取该值，并使该值在 Internet 上更难搜索。

"target"名称/值对的值是特定错误的目标（例如，错误的属性的名称）。

"details"名称/值对的值必须是 JSON 对象的数组，这些对象必须包含"code"和"message"的名称/值对，并且可能包含"target"的名称/值对，如上所述。
"details"数组中的对象通常表示请求期间发生的不同的相关错误。
请参阅下面的示例。

"innererror"名称/值对的值必须是对象。
此对象的内容是服务定义的。
想要返回比根级别代码更具体的错误的服务必须通过包含"code"的名称/值对和嵌套的"innererror"来执行此操作。每个嵌套的"innererror"对象表示比其父对象更高级别的细节。
在评估错误时，客户端必须遍历所有嵌套的"innererror"，并选择他们理解的最深层次的错误。
此方案允许服务在层次结构中的任何位置引入新的错误代码，而不会破坏向后兼容性，只要旧的错误代码仍然出现。
该服务可能会向不同的调用者返回不同级别的深度和详细信息。
例如，在开发环境中，最深层的"innererror"可能包含可帮助调试服务的内部信息。
为了防止围绕信息泄露的潜在安全问题，服务应注意不要无意中暴露太多细节。
错误对象还包括可能特定于代码的自定义服务器定义的名称/值对。
具有自定义服务器定义属性的错误类型应在服务的元数据文档中声明。
请参阅下面的示例。

错误响应可能在其任何 JSON 对象中包含[annotations][odata-json-annotations]。

我们建议，对于可以重试的任何暂时性错误，服务应包含"Retry-After"HTTP 响应头，指示客户端在再次尝试操作之前应等待的最小秒数。

##### ErrorResponse： 对象

属性 | 类型 | 必填 | 描述
-------- | ---- | -------- | -----------
`error` | Error | ✔ | 错误对象。

##### Error ： 对象

属性 | 类型 | 必填 | 描述
-------- | ---- | -------- | -----------
`code` | String | ✔ | 服务器定义的一组错误代码之一。
`message` | String | ✔ | 人类可读形式的错误信息。
`target` | String |  | 错误的目标。
`details` | Error[]|  | 有关导致此报告错误的特定错误的一系列详细信息。
`innererror` | InnerError |  | 包含比当前对象更具体的有关错误的信息的对象。

##### InnerError ： 对象

属性 | 类型 | 必填 | 描述
-------- | ---- | -------- | -----------
`code` | String |  | 比包含错误提供的更具体的错误代码。
`innererror` | InnerError |  | 包含比当前对象更具体的有关错误的信息的对象。

##### 例子

"innererror"的示例：

```json
{
  "error": {
    "code": "BadArgument",
    "message": "Previous passwords may not be reused",
    "target": "password",
    "innererror": {
      "code": "PasswordError",
      "innererror": {
        "code": "PasswordDoesNotMeetPolicy",
        "minLength": "6",
        "maxLength": "64",
        "characterTypes": ["lowerCase","upperCase","number","symbol"],
        "minDistinctCharacterTypes": "2",
        "innererror": {
          "code": "PasswordReuseNotAllowed"
        }
      }
    }
  }
}
```

在这个示例中，最基本的错误代码是"BadArgument"，但对于感兴趣的客户端，"innererror"中有更具体的错误代码。
"PasswordReuseNotAllowed"代码可能是该服务在以后添加的，以前只返回了"PasswordDoesNotMeetPolicy"。
添加新的错误代码时，现有客户端不会中断，但新客户端可能会利用它。
"PasswordDoesNotMeetPolicy"错误还包括其他名称/值对，这些名称/值对允许客户端确定服务器的配置、以编程方式验证用户的输入或在客户端自己的本地化消息传递中向用户显示服务器的约束。

"details"示例：

```json
{
  "error": {
    "code": "BadArgument",
    "message": "Multiple errors in ContactInfo data",
    "target": "ContactInfo",
    "details": [
      {
        "code": "NullValue",
        "target": "PhoneNumber",
        "message": "Phone number must not be null"
      },
      {
        "code": "NullValue",
        "target": "LastName",
        "message": "Last name must not be null"
      },
      {
        "code": "MalformedValue",
        "target": "Address",
        "message": "Address is not valid"
      }
    ]
  }
}
```

在此示例中，请求存在多个问题，每个错误都列在"details"中。

### 7.11. HTTP 状态码
应使用标准 HTTP 状态码;有关详细信息，请参阅 HTTP 状态码定义。

### 7.12. 可选的客户端库
开发人员必须能够在各种平台和语言上进行开发，例如Windows，macOS，Linux，C#，Python，Node.js和Ruby。

服务应该能够通过简单的HTTP工具（如curl）轻松访问。

服务开发者门户应提供等效的"获取开发人员令牌"，以促进试验和 curl 支持。

## 8. CORS 
符合 Microsoft REST API 指南的服务必须支持 [CORS（跨域资源共享）][cors]。
服务应支持允许的 CORS * 源，并通过有效的 OAuth 令牌强制实施授权。
服务不应支持带有来源验证的用户凭证。
特殊情况可能有例外。

### 8.1. 客户指导
Web开发人员通常不需要做任何特殊的事情来利用CORS。
所有握手步骤都是作为它们进行的标准 XMLHttpRequest 调用的一部分在不可见的情况下发生的。

许多其他平台（如 .NET）都集成了对 CORS 的支持。

#### 8.1.1. 避免预检
由于 CORS 协议可能会向服务器添加额外往返的预检请求，因此性能关键型应用可能有兴趣避免这些请求。
CORS 背后的精神是避免对旧的不支持 CORS 的浏览器能够发出的任何简单的跨域请求进行预检。
所有其他请求都需要预检。

如果请求的方法是 GET、HEAD 或 POST，并且除了Accept、Accept-Language和Content-Language之外不包含任何请求标头，则请求是"简单"的，并且会避免预检。
对于 POST 请求，也允许使用 Content-Type 标头，但前提是其值为"application/x-www-form-urlencoded"、"multipart/form-data"或"text/plain"。
对于任何其他标头或值，将发生预检请求。

### 8.2. 服务指导
至少，服务必须：
- 了解浏览器在跨域请求上发送的Origin请求标头，以及浏览器在检查访问权限的预检选项请求时发送的Access-Control-Request-Method请求标头。
- 如果请求中存在 Origin 标头：
    - 如果请求使用 OPTIONS 方法并包含Access-Control-Request-Method标头，则它是一个预检请求，旨在实际请求之前探测访问。否则，它将是实际请求。对于预检请求，除了执行以下步骤添加标头之外，服务必须不执行任何其他处理，并且必须返回 200 OK。对于非预检请求，除了请求的常规处理之外，还会添加以下标头。
    - 在响应中添加 Access-Control-Allow-Origin 标头，包含与Origin请求标头相同的值。请注意，这需要服务动态生成标头值。不需要 Cookie 或任何其他形式的 [用户凭据][cors-user-credentials] 的资源可能会用通配符星号 （*） 来响应。请注意，通配符仅在此处可接受，不适用于下面描述的任何其他标头。
    - 如果调用者需要访问不在 [simple response headers][cors-simple-headers] 集合中的响应头（Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma），则添加一个访问控制公开标头标头，其中包含客户端应有权访问的其他响应标头名称的列表。
    - 如果请求需要 Cookie，则添加一个Access-Control-Allow-Credentials 标头并设置为“true”。
    - 如果请求是预检请求（请参阅第一个项目符号），则服务必须：
        - 添加Access-Control-Allow-Headers响应标头，其中包含允许客户端使用的请求标头名称列表。此列表只需包含不在 [simple request headers][cors-simple-headers] （Accept、Accept-Language、Content-Language） 集合中的标头。如果对服务接受的标头没有限制，则服务可以简单地返回与客户端发送的Access-Control-Request-Headers标头相同的值。
        - 添加一个Access-Control-Allow-Methods响应标头，其中包含允许调用者使用的 HTTP 方法列表。

添加一个 Access-Control-Max-Age 优先的响应标头，其中包含此预检响应有效的秒数（因此可以在后续实际请求之前避免）。请注意，虽然习惯上使用较大的值如 2592000（30 天），但许多浏览器会自行施加一个低得多的限制（例如，五分钟）。

由于浏览器预检响应缓存是出了名的弱，因此预检响应的额外往返会损害性能。
性能至关重要的交互式 Web 客户端使用的服务应避免导致预检请求的模式
- 对于 GET 和 HEAD 调用，请避免要求不属于上述简单集的请求标头。允许将它们作为查询参数提供。
    - 授权标头不是简单集的一部分，因此对于需要身份验证的资源，必须改为通过"access_token"查询参数发送身份验证令牌。请注意，不建议在 URL 中传递身份验证令牌，因为这可能导致令牌记录在服务器日志中，并暴露给有权访问这些日志的任何人。通过 URL 接受身份验证令牌的服务必须采取措施来降低安全风险，例如使用短期身份验证令牌、禁止记录身份验证令牌以及控制对服务器日志的访问。

- 避免需要 Cookie。XmlHttpRequest 只有在设置了"withCredentials"属性时才会在跨域请求上发送 Cookie;这也会导致预检请求。
    - 需要基于 Cookie 的身份验证的服务必须使用"dynamic canary"来保护所有接受 Cookie 的 API。

- 对于 POST 调用，在适用的情况下，首选集合（"application/x-www-form-urlencoded"、"multipart/form-data"、"text/plain"）中的简单Content-Type。任何其他Content-Type都将引发预检请求。
    - 服务不得以避免 CORS 预检请求的名义违反其他 API 建议。特别是，根据建议，由于Content-Type，大多数POST请求实际上需要预检请求。
    - 如果消除预检至关重要，则服务可能支持数据传输的替代机制，但还必须支持推荐的方法。

此外，在适当的时候，服务可能支持 JSONP 模式，以实现简单的、仅限 GET 的跨域访问。
在 JSONP 中，服务接受一个指示格式的参数 （_$format=json_） 和一个指示回调的参数 （_$callback=someFunc_），并返回一个text/javascript 文档，其中包含包装在具有指定名称的函数调用中的 JSON 响应。
有关 JSONP 的更多信息，请访问维基百科： [JSONP](https://en.wikipedia.org/wiki/JSONP).

## 9. 集合
### 9.1. 项目键
服务可能支持集合中每个资源的持久标识符，并且该标识符应在 JSON 中表示为"id"。这些持久标识符通常用作资源项键。

支持持久标识符的集合可能支持增量查询。

### 9.2. 序列化
在JSON中集合使用标准数组表示法表示。

### 9.3. 集合 URL 模式
当集合处于顶级时，它们直接位于服务根下，或者当范围限定为该资源时，它们将作为该资源下的一部分。

例如：

```http
GET https://api.contoso.com/v1.0/people
```

只要有可能，服务必须支持"/"模式。
例如：

```http
GET https://{serviceRoot}/{collection}/{id}
```

参数：
- {serviceRoot} – 主机（站点 URL）+ 服务的根路径的组合
- {collection} – 集合的名称，未缩写，复数
- {id} – 唯一 id 属性的值。使用"/"模式时，它必须是原始字符串/数字/guid值，不带引号但正确转义以适合URL。

#### 9.3.1. 嵌套集合和属性
集合项可能包含其他集合。
例如，一个用户集合可能包含具有多个地址的用户资源：

```http
GET https://api.contoso.com/v1.0/people/123/addresses
```

```json
{
  "value": [
    { "street": "1st Avenue", "city": "Seattle" },
    { "street": "124th Ave NE", "city": "Redmond" }
  ]
}
```

### 9.4. 大集合
随着数据的增长，集合也会随之增长。
规划分页对于所有服务都很重要。
因此，当多个页面可用时，序列化载荷必须包含下一页的不透明 URL（根据需要）。
有关更多详细信息，请参阅分页指南。

对任何给定的请求，客户端必须能够适应分页或非分页的集合数据。

```json
{
  "value":[
    { "id": "Item 1","price": 99.95,"sizes": null},
    { … },
    { … },
    { "id": "Item 99","price": 59.99,"sizes": null}
  ],
  "@nextLink": "{opaqueUrl}"
}
```

### 9.5. 更改集合
POST 请求不是幂等的。
这意味着，发送同样的 POST 请求可能会导致创建多个资源项。
对由服务器端生成资源项ID的项目执行插入操作，通常会发生这种情况。

例如，以下请求：

```http
POST https://api.contoso.com/v1.0/people
```

将返回指示新集合项位置的响应：

```http
201 Created
Location: https://api.contoso.com/v1.0/people/123
```

一旦再次执行，可能会导致新建另一个资源：

```http
201 Created
Location: https://api.contoso.com/v1.0/people/124
```

而 PUT 请求需要使用相应的资源项键值：

```http
PUT https://api.contoso.com/v1.0/people/123
```

### 9.6. 对集合进行排序
集合查询的结果可以根据属性值进行排序。
该属性由_$orderBy_查询参数的值确定。

_$orderBy_ 参数的值包含一个逗号分隔的表达式列表，用于对项目进行排序。
此类表达式的一个特例是以基础属性结尾的属性路径。

表达式可以包括后缀"asc"表示升序，后缀"desc"表示降序，与属性名称之间用一个或多个空格分隔。
如果未指定"asc"或"desc"，则服务必须按指定属性按升序排序。

NULL 值必须排序为"小于"非 NULL 值。

项目必须按第一个表达式的结果值排序，然后对第一个表达式具有相同值的项目按第二个表达式的结果值排序，依此类推。
排序顺序是属性类型的固有顺序。

例如：

```http
GET https://api.contoso.com/v1.0/people?$orderBy=name
```

将返回按姓名升序排序的所有人员。

例如：

```http
GET https://api.contoso.com/v1.0/people?$orderBy=name desc
```

将返回按姓名降序排序的所有人员。

子排序可以通过逗号分隔的属性名称列表（带有可选方向限定符）来指定。

例如：

```http
GET https://api.contoso.com/v1.0/people?$orderBy=name desc,hireDate
```

将返回按姓名按降序排序的所有人员，并按升序返回按日期排序的次要排序顺序。

排序必须与过滤一起组成，例如：

```http
GET https://api.contoso.com/v1.0/people?$filter=name eq 'david'&$orderBy=hireDate
```

将返回所有名字为David的人，按hireDate的升序排序。

#### 9.6.1. 解释排序表达式
排序参数必须在页面之间保持一致，因为客户端和服务器端分页都与排序完全兼容。

如果服务不支持按$orderBy表达式中某一属性进行排序，则该服务必须使用响应中"不受支持的请求"部分里定义的错误消息进行响应。

### 9.7. 过滤
_$filter_查询字符串参数允许客户端筛选资源集合。
将针对集合中的每个资源计算使用 $filter 指定的表达式，并且响应中仅包含表达式计算结果为 true 的项。
表达式计算结果为 false 或 null 的资源，或者由于权限而不可用的引用属性的资源，将从响应中省略。

示例：返回价格低于 $10.00 的所有产品

```http
GET https://api.contoso.com/v1.0/products?$filter=price lt 10.00
```

_$filter_ 选项的值是布尔表达式。

#### 9.7.1. 过滤器操作
支持 _$filter_ 的服务应支持以下最小操作集。

算子             | 描述           | 例
-------------------- | --------------------- | -----------------------------------------------------
比较运算符 |                       |
eq                   | 相等                 | city eq 'Redmond'
nw                  | 不相等             | city ne 'London'
gt                   | 大于          | price gt 20
ge                   | 大于或等于 | price ge 10
lt                   | 小于             | price lt 20
le                   | 小于或等于    | price le 100
逻辑运算符    |                       |
and                  | 逻辑和           | price le 200 and price gt 3.5
or                   | 逻辑或            | price le 3.5 or price gt 200
not                  | 逻辑否定      | not price le 3.5
分组运算符   |                       |
( )                  | 优先级分组   | （priority eq 1 or city eq "Redmond"）and price gt 100

#### 9.7.2. 运算符示例
以下示例说明了每个逻辑运算符的用法和语义。

示例：名称等于"Milk"的所有商品

```http
GET https://api.contoso.com/v1.0/products?$filter=name eq 'Milk'
```

示例：名称不等于"Milk"的所有商品

```http
GET https://api.contoso.com/v1.0/products?$filter=name ne 'Milk'
```

示例：所有名为"Milk"且价格也低于 2.55 的产品：

```http
GET https://api.contoso.com/v1.0/products?$filter=name eq 'Milk' and price lt 2.55
```

示例：所有名为"Milk"或价格低于 2.55 的产品：

```http
GET https://api.contoso.com/v1.0/products?$filter=name eq 'Milk' or price lt 2.55
```

示例：所有名为"Milk"或"Eggs"且价格低于 2.55 的产品：

```http
GET https://api.contoso.com/v1.0/products?$filter=(name eq 'Milk' or name eq 'Eggs') and price lt 2.55
```

#### 9.7.3. 运算符优先级
在计算 _$filter_ 表达式时，服务必须对支持的运算符使用以下运算符优先级。
运算符按类别按优先级从高到低顺序列出。
同一类别中的运算符具有相同的优先级：

| 分组           | 算子 | 描述           |
|:----------------|:---------|:----------------------|
| 分组        | ( )      | 优先级分组   |
| 一元运算符           | not      | 逻辑否定      |
| 关系      | gt       | 大于          |
|                 | ge       | 大于或等于 |
|                 | lt       | 小于             |
|                 | le       | 小于或等于    |
| 等式        | eq       | 相等                 |
|                 | ne       | 不相等             |
| 条件和 | and      | 逻辑和           |
| 条件或  | or       | 逻辑或            |

### 9.8. 分页
返回集合的 RESTful API 可能会返回部分集合。
这些服务的使用者必须期望部分结果集，并正确翻页以检索整个结果集。

RESTful API 可能支持两种形式的分页。
服务器驱动的分页通过强制对多个响应负载的请求进行分页来缓解拒绝服务攻击。
客户端驱动的分页使客户端能够仅请求它在给定时间可以使用的资源数。

排序和过滤参数必须在页面之间保持一致，因为客户端和服务器端分页都与过滤和排序完全兼容。

#### 9.8.1. 服务器驱动的分页
分页响应必须通过在响应中包含延续标记来指示部分结果。
没有延续令牌意味着没有其他分页可用了。

客户端必须将延续 URL 视为不透明，这意味着在循环访问一组部分结果时，查询选项不得更改。

例：

```http
GET http://api.contoso.com/v1.0/people HTTP/1.1
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{
  ...,
  "value": [...],
  "@nextLink": "{opaqueUrl}"
}
```

#### 9.8.2. 客户端驱动的分页
客户端可以使用 _$top_ 和 _$skip_ 查询参数来指定要返回的结果数量和集合中的偏移量。

服务器应遵循客户端指定的值;但是，客户端必须准备好处理包含不同页面大小或包含延续令牌的响应。

当客户端同时提供_$top_和_$skip时_，服务器应首先应用_$skip_然后应用_$top_。

注意：如果服务器无法接受 _$top_ 或 _$skip_，则服务器必须向客户端返回错误，而不是忽略查询选项。
这将避免客户对返回的数据做出假设的风险。

例如：

```http
GET http://api.contoso.com/v1.0/people?$top=5&$skip=2 HTTP/1.1
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{
  ...,
  "value": [...]
}
```

#### 9.8.3. 其他注意事项
**稳定排序的前提：** 两种形式的分页都取决于具有稳定排序的项目的集合。
服务器必须使用其他排序（通常按ID）来补充任何指定的次序条件，以确保项目始终一致地排序。

**丢失/重复的结果：** 即使服务器强制实施一致的排序顺序，结果也可能丢失或重复（因为可能创建或删除其他资源）。
客户必须准备好处理这些差异。
服务器应始终对上次读取记录的记录ID进行编码，以帮助客户端管理重复/缺失的结果。

**结合客户端和服务器驱动的分页：** 请注意，客户端驱动的分页并不阻碍服务器驱动的分页。
如果客户端请求的分页大小大于服务器支持的默认分页大小，则预期的响应将是客户端指定的结果数，并按照服务器设置的分页配置进行分页。

**分页大小：**客户端可以通过指定 _$maxpagesize_ 首选项来请求具有特定分页大小的服务器驱动分页。
如果指定的分页大小小于服务器的默认分页大小，则服务器应遵循此首偏好。

**对嵌入式集合进行分页：** 客户端驱动的分页和服务器驱动的分页都可以应用于嵌入式集合。
如果服务器对嵌入式集合进行分页，则必须根据需要包含其他继续标记。

**记录集计数：** 想要了解所有页面的完整记录数的开发人员可以包含查询参数 _$count=true_ ，以告知服务器在响应中包括项目计数。

### 9.9. 复合集合操作
筛选、排序和分页操作都可以针对给定的集合执行。
当这些操作一起执行时，评估顺序必须为：

1. **筛选**。这包括作为 AND 运算执行的所有范围表达式。
2. **排序**。列表根据排序条件进行排序。
3. **分页**。实例化的分页视图显示在筛选的排序列表上方（也就是先排序再分页）。这适用于服务器驱动的分页和客户端驱动的分页。

### 9.10. 空结果
当对集合执行筛选并且结果集为空时，必须使用有效的响应正文和 200 响应代码进行响应。
在此示例中，客户端提供的筛选器生成了一个空结果集。
响应正文将正常返回，并且 _value_ 属性设置为空集合。
根据您对产生结果的类似调用的响应格式，客户可能期望像 _maxItems_ 这样的元数据属性。
您应尽可能保持 API 的一致性。

```http
GET https://api.contoso.com/v1.0/products?$filter=(name eq 'Milk' or name eq 'Eggs') and price lt 2.55
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{
  ...,
  "maxItems": 0,
  "value": []
}
```

## 10. 增量查询

服务可以选择支持增量查询。

### 10.1. 增量链接
增量链接是不透明的、由服务生成的链接，客户端使用这些链接来检索对结果的后续更改。

在概念级别，增量链接基于一个定义查询，该查询描述正在跟踪其更改的一组结果。
增量链接对要跟踪其更改的实体的集合及跟踪更改的起点进行编码。

如果查询包含筛选器，则响应必须仅包含对与指定条件匹配的实体的更改。
增量查询的关键原则是：
- 集合中的每个项目都必须具有永久标识符。该标识符应表示为"id"。此标识符是服务定义的不透明字符串，客户端可以使用该字符串跨调用跟踪对象。
- 增量必须包含新匹配指定条件的每个实体的条目，并且必须包含不再与条件匹配的每个实体的"@removed"条目。
- 重新评估查询并将其与原始结果集进行比较;当前集中唯一的每个条目都必须作为 Add 操作返回，并且原始集中唯一的每个条目都必须作为"Remove"操作返回。
- 以前与条件不匹配但现在匹配的每个实体都必须作为"add"返回;相反，以前与查询匹配但不再匹配的每个实体都必须作为"@removed"条目返回。
- 已更改的实体必须使用其标准表示形式包含在集中。
- 服务可能会向"@removed"节点添加其他元数据，例如删除原因或"删除时间"时间戳。我们建议团队与 Microsoft REST API 指南工作组就扩展进行协调，以帮助保持一致性。

增量链接不得对任何客户端顶部或跳过值进行编码。

### 10.2. 实体表示
添加和更新的实体在实体集中使用其标准表示形式表示。
从集合的角度来看，添加或更新的实体之间没有区别。

删除的实体仅使用其"id"和"@removed"节点表示。
"@removed"节点的存在必须表示从集合中删除条目。

### 10.3. 获取增量链路
增量链接是通过查询集合或实体并追加$delta查询字符串参数来获取的。
例如：

```http
GET https://api.contoso.com/v1.0/people?$delta
HTTP/1.1
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{
  "value":[
    { "id": "1", "name": "Matt"},
    { "id": "2", "name": "Mark"},
    { "id": "3", "name": "John"}
  ],
  "@deltaLink": "{opaqueUrl}"
}
```

注意：如果对集合进行分页，则 deltaLink 将仅出现在最后一页上，但必须反映对所有页面上返回的数据的任何更改。

### 10.4. 增量链路响应的内容
添加/更新的条目必须显示为常规 JSON 对象，并具有常规项目属性。
以常规表示形式返回添加/修改的项允许客户端使用基于"id"字段的标准合并概念将它们合并到其现有的"缓存"中。

从定义的集合中删除的条目必须包含在响应中。
从集合中删除的项目必须仅使用其"id"和"@removed"节点来表示。

### 10.5. 使用增量链路
客户端通过调用增量链路上的 GET 方法请求更改。
客户端必须按原样使用增量 URL -- 换句话说，客户端不得以任何方式修改 URL（例如，解析它并添加其他查询字符串参数）。
在此示例中：

```http
GET https://{opaqueUrl} HTTP/1.1
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{
  "value":[
    { "id": "1", "name": "Mat"},
    { "id": "2", "name": "Marc"},
    { "id": "3", "@removed": {} },
    { "id": "4", "name": "Luc"}
  ],
  "@deltaLink": "{opaqueUrl}"
}
```

针对增量链接的请求结果可能跨越多个页面，但服务必须对所有页面进行排序，以确保在应用于包含增量链接的响应时获得确定性结果。

如果未发生任何更改，则响应是一个空集合，其中包含用于后续更改（如果请求）的增量链接。
此增量链路可能与导致空的更改集合的增量链路相同。

如果增量链接不再有效，则服务必须响应 _410 Gone _。响应应包括一个 Location 标头，客户端可以使用该标头检索新的基线结果集。

## 11. JSON 标准化
### 11.1. 基本类型的 JSON 格式标准化
基本值必须按照 [RFC8259][rfc-8259] 的规则序列化为 JSON。

**64 位整数的重要说明：** JavaScript 将以静默方式截断大于 `Number.MAX_SAFE_INTEGER` （2^53-1） 的整数或小于 `Number.MIN_SAFE_INTEGER` （-2^53+1） 的数字。如果服务预期返回超出安全值范围的整数值，强烈建议考虑将值作为字符串返回，以最大限度地提高互操作性并避免数据丢失。

### 11.2. 日期和时间指南
#### 11.2.1. 生产日期
服务必须使用 `DateLiteral` 格式生成日期，并且应使用 `Iso8601Literal` 格式，除非有令人信服的理由用另外的格式。
使用 `StructuredDateLiteral` 格式的服务不得使用该格式生成日期 `T` ，除非同时需要额外的精度，并且 ECMAScript 客户端明确不受支持。
（非规范性声明：在决定哪个特定声明时 `DateKind` 为了标准化，偏好的大致顺序是 `E, C, U, W, O, X, I, T`。
这按此顺序针对 ECMAScript、.NET 和C++程序员进行了优化。

#### 11.2.2. 使用日期
服务必须接受来自使用与其生成的相同`DateLiteral`格式（包括 ）的客户端`DateKind`的日期，并且应接受使用任何格式的日期 `DateLiteral` 。

#### 11.2.3. 兼容性
服务必须对相同类型的所有资源使用相同的`DateLiteral`格式（包括相同的`DateKind`格式，如果适用），并且应该对整个服务中的所有资源使用相同的`DateLiteral`格式（如果`DateKind`适用，则使用相同的格式）。

对服务产生的`DateLiteral` 格式的任何更改（包括 `DateKind`，如果适用）以及`DateLiteral`格式（和 `DateKind`，如果适用）的任何减少都必须被视为重大更改。
服务接受的任何 `DateLiteral`格式的扩展均不被视为重大更改。

### 11.3. 日期和时间的 JSON 序列化
使用 JSON 往返序列化日期是一个难题。
尽管 ECMAScript 支持大多数内置类型的文本，但它没有定义日期的文字格式。
Web 已经 合并了 [ECMAScript subset of ISO 8601 date formats (ISO 8601)][iso-8601]，但在某些情况下，这种格式并不可取。
对于这些情况，本文档定义了一种 JSON 序列化格式，可用于明确表示不同格式的日期。
其他序列化格式（如 XML）可以从这种格式派生。

#### 11.3.1.  `DateLiteral` 格式
JSON 中表示的日期使用以下语法进行序列化。
非正式地， `DateValue` 可以是 ISO 8601 格式的字符串，也可以是，其中包含两个名为“kind”和“value”的属性，它们共同定义了一个时间点。
以下不是上下文无关的语法;特别是， `DateValue` 的解释取决于  `DateKind` 的值，但这最大限度地减少了描述格式所需的产生式数量。

```
DateLiteral:
  Iso8601Literal
  StructuredDateLiteral

Iso8601Literal:
  https://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15 中定义的字符串文字。请注意，不支持 ISO 8601 的完整语法（例如没有分隔符的“基本格式”）。
  除非另有说明，否则所有日期默认为 UTC。

StructuredDateLiteral:
  { DateKindProperty , DateValueProperty }
  { DateValueProperty , DateKindProperty }

DateKindProperty
  "kind" : DateKind

DateKind:
  "C"            ; 见下文
  "E"            ; 见下文
  "I"            ; 见下文
  "O"            ; 见下文
  "T"            ; 见下文
  "U"            ; 见下文
  "W"            ; 见下文
  "X"            ; 见下文

DateValueProperty:
  "value" : DateValue

DateValue:
  UnsignedInteger        ; 此处未定义
  SignedInteger        ; 此处未定义
  RealNumber        ; 此处未定义
  Iso8601Literal        ; 此处未定义
```

#### 11.3.2. 关于日期格式的说明
使用 `Iso8601Literal` 产生的 `DateLiteral` 相对简单。
下面是一个对象的示例，其属性名为 `creationDate`，该属性设置为 February 13, 2015, at 1:15 p.m. UTC：

```json
{ "creationDate" : "2015-02-13T13:15Z" }
```

 `StructuredDateLiteral` 由 `DateKind` 和 随附的 `DateValue` 组成，其有效值（及其解释）取决于 `DateKind`。下表描述了有效的组合及其含义：

DateKind | DateValue       | 俗名和解释                                                                                                                  | 更多信息
-------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------
C        | UnsignedInteger | "CLR";自 0001 年 1 月 1 日午夜以来的毫秒数;不允许使用负值。 *请参阅下面的注释。*| [MSDN][clr-time]
E        | SignedInteger   | "ECMAScript";自 1970 年 1 月 1 日午夜以来的毫秒数。                                                                             | [ECMA International][ecmascript-time]
I        | Iso8601Literal  | "ISO 8601";仅限于 ECMAScript 子集的字符串。                                                                                            |
O        | RealNumber      | "OLE Date";整数部分是自 1899 年 12 月 31 日午夜以来的天数，小数部分是一天中的时间（0.5 = 中午）。 | [MSDN][ole-date]
T        | SignedInteger   | "Ticks";自 1601 年 1 月 1 日午夜以来的滴答数（100 纳秒间隔）。 *请参阅下面的注释。*| [MSDN][ticks-time]
U        | SignedInteger   | "UNIX";自1970年1月1日午夜以来的秒数。                                                                                        | [MSDN][Unix-time]
W        | SignedInteger   | "Windows";自 1601 年 1 月 1 日午夜以来的毫秒数。 *请参阅下面的注释。*| [MSDN][windows-time]
X        | RealNumber      | "Excel";至于 `O`， 但 1900 年被错误地视为闰年，第 0 天是"1 月 0 日（零）"。                                     | [Microsoft Support][excel-time]

** `C` 和 `W` 类型的重要说明：** 本机 CLR 和 Windows 时间由 100 纳秒的"滴答"值表示。
为了与精度有限的 ECMAScript 客户端进行互操作， （反）序列化为 `DateLiteral` 时，_这些值必须与毫秒相互转换_ 。
一毫秒相当于 10，000 个滴答。

**关于 `T` 类型的重要说明：** 这种类型保留了 Windows 本机时间格式的完整保真度（并且可以轻松地与本机 CLR 格式相互转换），但与 ECMAScript 客户端不兼容。
因此，它的使用应仅限于那些既需要额外精度又不需要与 ECMAScript 客户端互操作的场景。

下面是一个具有名为 creationDate 的属性的对象的相同示例，该对象设置为 February 13, 2015, at 1:15 p.m. UTC，使用多种格式：

```json
[
  { "creationDate" : { "kind" : "O", "value" : 42048.55 } },
  { "creationDate" : { "kind" : "E", "value" : 1423862100000 } }
]
```

将kind与value分离的好处之一是，一旦客户端知道特定服务使用的kind，它就可以解释value，而无需任何额外的解析。
在值为数字的常见情况下，这使得开发人员更容易编码：

```csharp
// 我们知道这个服务总是给出 ECMAScript 格式的日期
var date = new Date(serverResponse.someObject.creationDate.value);
```

### 11.4. 持续时间
[Durations][wikipedia-iso8601-durations] 需要按照 [ISO 8601][wikipedia-iso8601-durations]。
持续时间"由格式`P[n]Y[n]M[n]DT[n]H[n]M[n]S`表示"。
从标准：
- P 是持续时间指示符（历史上称为“周期”），放置在持续时间表示的开头。
- Y 是年数值后面的年份指示符。
- M 是月份数值后面的月份指示符。
- W 是周数值后面的周指示符。
- D 是日数值后面的日期指示符。
- T 是表示的时间分量之前的时间指示符。
- H 是小时数值后面的小时指示符。
- M 是分钟数值后面的分钟指示符。
- S 是秒数值后面的第二个指示符。

例如，"P3Y6M4DT12H30M5S"表示"三年六个月四天十二小时三十分钟和五秒"的持续时间。

### 11.5. 间隔
[Intervals][wikipedia-iso8601-intervals] 被定义为 [ISO 8601][wikipedia-iso8601-intervals] 的一部分。
- 开始和结束，例如 "2007-03-01T13:00:00Z/2008-05-11T15:30:00Z"
- 开始和持续时间，例如"2007-03-01T13:00:00Z/P1Y2M10DT2H30M"
- 持续时间和结束，例如"P1Y2M10DT2H30M/2008-05-11T15:30:00Z"
- 仅持续时间，例如"P1Y2M10DT2H30M"，带有附加上下文信息

### 11.6. 重复间隔
[Repeating Intervals][wikipedia-iso8601-repeatingintervals]，根据 [ISO 8601][wikipedia-iso8601-repeatingintervals]，是：

> 通过在区间表达式的开头添加“R[n]/”形成，其中 R 用作字母本身，[n] 由重复次数代替。
省略 [n] 的值意味着无限次数的重复。

例如，若要从"2008-03-01T13:00:00Z,"开始重复"P1Y2M10DT2H30M"间隔五次，请使用"R5/2008-03-01T13:00:00Z/P1Y2M10DT2H30M."。

## 12. 版本控制
**所有符合 Microsoft REST API 指南的 API 都必须支持显式版本控制。** 至关重要的是，客户端可以依靠服务随着时间的推移保持稳定，并且服务可以添加功能和进行更改也很重要。

### 12.1. 版本控制格式
服务使用 Major.Minor 版本控制方案进行版本控制。
服务可以选择仅"Major"版本方案，在这种情况下，".0"是隐含的，并且本节中的所有其他规则都适用。
支持指定 REST API 请求版本的两个选项：
- 嵌入在请求 URL 的路径中，在服务根的末尾： `https://api.contoso.com/v1.0/products/users`
- 作为 URL 的查询字符串参数： `https://api.contoso.com/products/users?api-version=1.0`

在这两个选项之间进行选择的指南如下：

1. 位于 DNS 端点后面的同一位置的服务必须使用相同的版本控制机制。
2. 在这种情况下，跨端点的一致用户体验至关重要。Microsoft REST API 指南工作组建议，在没有与组织的领导团队进行明确对话的情况下，不要创建新的顶级 DNS 端点。
3. 保证其 REST API 的 URL 路径稳定性的服务（即使通过 API 的未来版本）也可以采用查询字符串参数机制。这意味着 API 中描述的关系的命名和结构在 API 发布后无法演变，即使在具有重大更改的版本之间也是如此。
4. 无法确保未来版本中 URL 路径稳定性的服务必须将版本嵌入到 URL 路径中。

某些基础服务（如Microsoft的Azure Active Directory）可能暴露在多个端点后面。
此类服务必须支持每个端点的版本控制机制，即使这意味着支持多种版本控制机制。

#### 12.1.1. 组版本
组版本控制是一项可选功能，可以使用查询字符串参数机制在服务上提供。
组版本允许在通用版本控制名称下对 API 端点进行逻辑分组。
这允许开发人员查找单个版本号，并跨多个端点使用它。
组版本号是众所周知的，服务应拒绝任何无法识别的值。

在内部，服务将采用组版本并将其映射到相应的 Major.Minor 版本。

组版本格式定义为 YYYY-MM-DD，例如 2012 年 12 月 7 日的 2012-12-07。此日期版本格式仅适用于组版本，不应用作Major.Minor版本的替代方法。

##### 组版本示例

| 组      | Major.Minor |
|:-----------|:------------|
| 2012-12-01 | 1.0         |
|            | 1.1         |
|            | 1.2         |
| 2013-03-21 | 1.0         |
|            | 2.0         |
|            | 3.0         |
|            | 3.1         |
|            | 3.2         |
|            | 3.3         |

版本格式                | 例                | 解释
----------------------------- | ---------------------- | ------------------------------------------
{groupVersion}                | 2013-03-21, 2012-12-01 | 3.3, 1.2
{majorVersion}                | 3                      | 3.0
{majorVersion}.{minorVersion} | 1.2                    | 1.2

客户端可以指定组版本或 Major.Minor 版本：

例如：

```http
GET http://api.contoso.com/acct1/c1/blob2?api-version=1.0
```

```http
PUT http://api.contoso.com/acct1/c1/b2?api-version=2011-12-07
```

### 12.2. 何时实施版本
服务必须递增其版本号以响应任何重大 API 更改。
有关构成重大更改的内容的详细讨论，请参阅以下部分。
如果需要，服务也可以为非重大更改增加其版本号。

使用新的主版本号来表示将来将弃用对现有客户端的支持。
在引入新的主要版本时，服务必须为现有客户提供清晰的升级路径，并制定与其业务组策略一致的弃用计划。
服务应为所有其他更改使用新的次要版本号。

版本化服务的在线文档必须指明每个先前 API 版本的当前支持状态，并提供最新版本的路径。

### 12.3. 重大变更的定义
对 API 协定的更改被视为重大更改。
影响 API 向后兼容性的更改是重大更改。

团队可以根据业务需求定义向后兼容性。
例如，Azure 将在响应中添加新 JSON 字段定义为不向后兼容。
Office 365 对向后兼容性的定义较宽松，并允许将 JSON 字段添加到响应中。

重大更改的明确示例：

1. 删除或重命名 API 或 API 参数
2. 现有 API 的行为更改
3. 错误代码和故障约定的更改
4. 任何违反 [Principle of Least Astonishment][principle-of-least-astonishment] 的事情

服务必须显式定义其对重大更改的定义，尤其是在向 JSON 响应添加新字段以及使用默认字段添加新的 API 参数方面。
与其他服务位于 DNS 端点后面的服务在定义协定可扩展性时必须保持一致。

[in this section of the OData V4 spec][odata-breaking-changes] 描述的适用更改应被视为所有服务必须考虑的重大更改的最低标准的一部分。

## 13. 长时间运行操作
长时间运行的操作（有时称为异步操作）对不同的人往往意味着不同的事情。
本节针对不同类型的长时间运行操作提供指南，并介绍这些操作类型的协议和最佳实践。

1. 一个或多个客户端必须能够同时监控和操作同一资源。
2. 系统的状态应始终是可发现和可测试的。即使操作跟踪资源不再处于活动状态，客户端应该能够确定系统状态。查询长时间运行的操作的状态的行为本身应该利用 Web 的原则。即具有统一接口语义的明确定义的资源。客户端可能会对某些资源发出 GET，以确定长时间运行的操作的状态
3. 长期运行的操作应该适用于希望"一劳永逸（Fire and Forget）"的客户以及希望积极监控并根据结果采取行动的客户。
4. 取消并不明确意味着回滚。在每个 API 定义的情况下，它可能意味着回滚、补偿、完成或部分完成等。在取消操作后，客户端不应负责将服务返回到允许继续服务的一致状态。

### 13.1. 基于资源的长时间运行操作 （RELO）
基于资源的建模是将操作的状态编码在资源中，并且使用的协议是标准同步协议。
在此模型中，状态转换定义清晰，目标状态定义类似。

_这是长时间运行操作的首选模型，应尽可能使用。_ 避免LRO Wire Protocol的复杂性和机制使我们的用户和工具链更加简单。

例如，计算机重新启动，其中操作本身同步完成，但虚拟机资源上的 GET 操作将具有可以随时查询的"state: Rebooting"、"state: Running"。

此模型可能集成了推送通知。

虽然大多数操作可能是 POST 语义，但除了 POST 语义，服务还可以通过路由支持 PUT 语义以简化其 API。
例如，想要创建名为"db1"的数据库的用户可以调用：

```http
PUT https://api.contoso.com/v1.0/databases/db1
```

在这种情况下，数据库段正在处理 PUT 操作。

服务也可以使用下面定义的混合。

### 13.2. 逐步长时间运行操作
逐步操作是指需要很长时间（通常不可预测的）时间长度才能完成的操作，并且不提供在资源中建模的状态转换。
本节概述了服务应用于公开此类长时间运行的操作的方法。

服务可能会公开逐步操作。

> 逐步长时间运行的操作有时称为"异步"操作。
这会导致混淆，因为它将平台元素（"Async / await", "promises", "futures"）与API操作的元素混合在一起。
本文档使用术语"逐步长时间运行操作"或通常仅使用"逐步操作"，以避免混淆单词"异步"。

服务必须对逐步请求执行尽可能多的同步验证。
服务必须以同步方式优先返回错误，目标是使用长时间运行的操作连接协议仅处理"有效"操作。

对于定义为逐步长时间运行操作的 API，即使可以立即完成操作，服务也必须经历逐步长时间运行操作流。
换句话说，API 必须采用并坚持 LRO 模式，而不是根据情况改变模式。

#### 13.2.1. PUT
服务可以启用 PUT 请求以创建实体。

```http
PUT https://api.contoso.com/v1.0/databases/db1
```

在此方案中， _databases_ 段正在处理 PUT 操作。

```http
HTTP/1.1 202 Accepted
Operation-Location: https://api.contoso.com/v1.0/operations/123
```

对于希望此处返回 201 Created 的服务，请使用下面描述的混合流。

202 Accepted 不应返回任何正文。
201 Created 应返回目标资源的正文。

#### 13.2.2. POST
服务可以启用 POST 请求来创建实体。

```http
POST https://api.contoso.com/v1.0/databases/

{
  "fileName": "someFile.db",
  "color": "red"
}
```

```http
HTTP/1.1 202 Accepted
Operation-Location: https://api.contoso.com/v1.0/operations/123
```

#### 13.2.3. POST，混合模型
对创建资源的集合的 POST 请求，服务可以同步快速响应，即使在生成响应时资源还没有完全创建。
为了使用此模式，响应必须包含不完整资源的表示和不完整的指示。

例如：

```http
POST https://api.contoso.com/v1.0/databases/ HTTP/1.1
Host: api.contoso.com
Content-Type: application/json
Accept: application/json

{
  "fileName": "someFile.db",
  "color": "red"
}
```

服务响应表示数据库已创建，但通过包含 Operation-Location 响应头指示请求未完成。
在这种情况下，响应负载中的 status 属性还指示操作尚未完全完成。

```http
HTTP/1.1 201 Created
Location: https://api.contoso.com/v1.0/databases/db1
Operation-Location: https://api.contoso.com/v1.0/operations/123

{
  "databaseName": "db1",
  "color": "red",
  "Status": "Provisioning",
  [ … other fields for "database" …]
}
```

#### 13.2.4. 操作资源
服务可以在租户级别提供"/operations"资源。

提供"/operations"资源的服务必须提供 GET 语义。
GET 必须按照标准分页、排序和筛选语义枚举操作集。
此操作的默认排序顺序必须为：

主要排序           | 二次排序
---------------------- | -----------------------
Not Started Operations | 操作创建时间
Running Operations     | 操作创建时间
Completed Operations   | 操作创建时间

请注意，"Completed Operations"是一个目标状态（见下文），实际上可能是几个不同状态中的任何一个，例如"成功"、"已取消"、"失败"等。

#### 13.2.5. operation 资源
operation 是跟踪逐步长时间运行的操作的用户可寻址资源。
操作必须支持 GET 语义。
针对操作的 GET 操作必须返回：

1. 操作资源、状态以及与特定 API 相关的任何扩展状态。
2. 200 OK 作为响应码。

服务可以通过在操作上公开 DELETE 来支持操作取消。
如果支持，则DELETE操作必须是幂等的。

> 注意：从 API 设计的角度来看，取消并不明确意味着回滚。
在每个 API 定义的情况下，它可能意味着回滚、补偿、完成或部分完成等。
在取消操作后，客户端不应负责将服务返回到允许继续服务的一致状态。

在发生 DELETE 时，不支持操作取消的服务必须返回 405 Not Allowed。

操作必须支持以下状态：

1. NotStarted
2. Running
3. Succeeded. 终结状态。
4. Failed. 终结状态。


服务可能会添加其他状态，例如"已取消"或"部分完成"。支持取消的服务必须充分描述其取消，以便可以准确地确定系统的状态，并且可以运行任何补偿操作。

支持其他状态的服务应考虑此规范名称列表，并尽可能避免创建新名称：Cancelling, Cancelled, Aborting, Aborted, Tombstone, Deleting, Deleted.

操作必须包含并在 GET 响应中提供以下信息：

1. 操作创建时的时间戳。
2. 进入当前状态的时间戳。
3. 操作状态（未启动/正在运行/已完成）。

服务可能会在操作中添加特定于 API 的其他字段。
返回的操作状态 JSON 如下所示：

```json
{
  "createdDateTime": "2015-06-19T12-01-03.45Z",
  "lastActionDateTime": "2015-06-19T12-01-03.45Z",
  "status": "notstarted | running | succeeded | failed"
}
```

##### 完成百分比
有时，服务不可能准确知道操作何时完成。
这使得使用 Retry-After 响应头有问题。
在这种情况下，服务可以在 operationStatus JSON 中包含一个完成百分比字段。

```json
{
  "createdDateTime": "2015-06-19T12-01-03.45Z",
  "percentComplete": "50",
  "status": "running"
}
```

在此示例中，服务器已向客户端指示长时间运行的操作已完成 50%。

##### 目标资源位置
对于导致或操作资源的操作，服务必须在操作完成时将目标资源位置包含在状态中。

```json
{
  "createdDateTime": "2015-06-19T12-01-03.45Z",
  "lastActionDateTime": "2015-06-19T12-06-03.0024Z",
  "status": "succeeded",
  "resourceLocation": "https://api.contoso.com/v1.0/databases/db1"
}
```

#### 13.2.6. 墓碑操作
服务可以选择支持墓碑操作。
服务可以选择在服务定义的时间段后删除墓碑。

#### 13.2.7. 典型流程，轮询
- 客户端通过使用 POST 调用操作来调用逐步操作
- 服务器必须通过响应 202 Accepted 状态码来指示请求已启动。响应应包括URL的location标头，客户端应在等待"Retry-After"标头中指定的秒数后轮询结果。
- 客户端轮询位置，直到收到带有终端操作状态的 200 响应。

##### 典型流程示例，轮询
客户端调用重启操作：

```http
POST https://api.contoso.com/v1.0/databases HTTP/1.1
Accept: application/json

{
  "fromFile": "myFile.db",
  "color": "red"
}
```

服务器响应表明请求已创建。

```http
HTTP/1.1 202 Accepted
Operation-Location: https://api.contoso.com/v1.0/operations/123
```

客户端等待一段时间，然后调用另一个请求以尝试获取操作状态。

```http
GET https://api.contoso.com/v1.0/operations/123
Accept: application/json
```

服务器响应结果仍未就绪，并选择性地提供等待 30 秒的建议。

```http
HTTP/1.1 200 OK
Retry-After: 30

{
  "createdDateTime": "2015-06-19T12-01-03.4Z",
  "status": "running"
}
```

客户端等待建议的 30 秒，然后调用另一个请求以获取操作结果。

```http
GET https://api.contoso.com/v1.0/operations/123
Accept: application/json
```

服务器以包含资源位置的"status:succeeded"操作响应。

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "createdDateTime": "2015-06-19T12-01-03.45Z",
  "lastActionDateTime": "2015-06-19T12-06-03.0024Z",
  "status": "succeeded",
  "resourceLocation": "https://api.contoso.com/v1.0/databases/db1"
}
```

#### 13.2.8. 典型流程，推送通知
1. 客户端通过使用 POST 调用操作来调用长时间运行的操作。客户端已在父资源上设置了推送通知。
2. 该服务通过响应 202 Accepted状态码来指示请求已启动。客户端忽略其他所有内容。
3. 整个操作完成后，服务将通过父资源上的订阅推送通知。
4. 客户端通过资源 URL 检索操作结果。

##### 典型流程示例，推送通知现有订阅
客户端调用备份操作。
客户端已经为 db1 设置了推送通知订阅。

```http
POST https://api.contoso.com/v1.0/databases/db1?backup HTTP/1.1
Accept: application/json
```

服务器响应表明请求已被接受。

```http
HTTP/1.1 202 Accepted
Operation-Location: https://api.contoso.com/v1.0/operations/123
```

调用者忽略返回中的所有标头。

操作完成后，目标 URL 会收到推送通知。

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "value": [
    {
      "subscriptionId": "1234-5678-1111-2222",
      "context": "subscription context that was specified at setup",
      "resourceUrl": "https://api.contoso.com/v1.0/databases/db1",
      "userId" : "contoso.com/user@contoso.com",
      "tenantId" : "contoso.com"
    }
  ]
}
```

#### 13.2.9. 重试
在上面的示例中，"Retry-After"请求头指示客户端在尝试从location请求头标识的 URL 获取结果之前应等待的秒数。

HTTP 规范允许 Retry-After 请求头以替代方式指定 HTTP 日期，因此客户端也应准备好处理此日期。

```http
HTTP/1.1 202 Accepted
Operation-Location: http://api.contoso.com/v1.0/operations/123
Retry-After: 60
```

注： HTTP 日期的使用与本文档中使用的 ISO 8601 日期格式的使用不一致，但在 [RFC 7231][rfc-7231-7-1-1-1] 中由 HTTP 标准明确定义。与 HTTP 日期格式相比，服务应首选整数秒数（十进制）格式。

### 13.3. 操作结果的保留策略
在某些情况下，长时间运行的操作的结果不是可以寻址的资源。
例如，如果调用返回布尔值（而不是资源）的长时间运行的操作。
在这些情况下，Location标头指向可以检索布尔结果的位置。

这就引出了一个问题："操作结果应该保留多长时间？"

建议的最短保留时间为 24 小时。

在从系统中清除之前，操作应该过渡到“墓碑”一段时间。

## 14. 限流、配额和限制
### 14.1. 原则
服务应尽可能响应，以免阻塞调用者。
根据经验，任何 API 调用在第 99 个百分位数中预计花费的时间超过 0.5 秒，都应考虑对这些调用使用长时间运行的操作模式。
显然，面对来自调用者的潜在无限负载，服务无法保证这些响应时间。因此，服务应为客户端设计和记录呼叫请求限制，并在超出这些限制时使用适当的、可操作的错误和错误消息进行响应。
当服务通常过载时，应该快速响应错误，而不是简单地缓慢响应。
最后，许多服务都有呼叫配额，可能是每小时或每天的一些操作，通常与服务计划或价格有关。
当超出这些配额时，服务还必须提供即时的、可操作的错误。
配额和限制的范围应限定为客户单位：订阅、租户、应用程序、计划，或者没有任何其他标识的 IP 地址范围...根据服务目标，以便正确共享负载，并且一个单元不会干扰另一个单元。

### 14.2. 返回代码（429 与 503）
HTTP 为这些方案指定了两个返回代码："429 Too Many Requests"和"503 Service Unavailable"。
对于客户端进行过多调用的情况，服务应使用 429，并且可以通过更改其调用模式来解决这种情况。
如果一般负载或单个调用者无法控制的其他问题导致服务变慢，则服务应使用 503 进行响应。
在所有情况下，服务还应提供信息，建议调用者在再次尝试之前应等待多长时间。
客户端应遵循这些标头，并实现其他短暂故障处理技术。
但是，有些客户端可能只是在失败后立即重试，这可能会增加服务的负载。
为了解决这个问题，服务应该设计成尽可能便宜地返回 429 或 503，要么通过放入特殊的快速路径代码，要么理想情况下通过依赖于提供此功能的通用前门或负载平衡器。

### 14.3. Retry-After 和 RateLimit 标头
Retry-After 标头是响应受到限制的客户端的标准方式。
在限制和配额（但不是整个系统负载）的情况下，使用描述超出的限制的标头进行响应也是常见但可选的。
但是，Microsoft 和整个行业的服务为此目的使用各种不同的标头。
我们建议使用三个标头来描述限制、限制下剩余的调用数以及重置限制的时间。
但是，其他标头可能适用于特定类型的限制。在所有情况下，这些都必须记录在案。

### 14.4. 服务指南
服务应根据 SLA 或业务目标选择适当的时间窗口。
在有配额的情况下，Retry-After时间和时间窗口可能非常长（几小时、几天、几周甚至几个月）。服务使用 429 表示特定调用者进行了过多调用，使用 503 表示服务正在减载，但这不是调用者的责任。

#### 14.4.1. 响应能力
1. 服务必须在所有情况下快速响应，即使在负载下也是如此。
2. 在第 99 个百分位响应时间超过 1 秒的调用应使用长时间运行的操作模式
3. 在第 99 百分位响应时间超过 0.5 秒的呼叫应强烈考虑 LRO 模式
4. 服务不应引入睡眠、暂停等，这会阻塞调用者或不可操作（"tar-pitting"）。

#### 14.4.2. 速率限制和配额
当调用者拨打过多电话时

1. 服务必须返回 429 代码
2. 服务必须返回描述细节的标准错误响应，以便程序员可以进行适当的更改
3. 服务必须返回Retry-After标头，指示客户端在重试之前应等待多长时间
4. 服务可能会返回RateLimit标头，表示已超出限制或配额
5. 服务可能返回RateLimit-Limit：允许客户端在一个时间窗口内调用的次数
6. 服务可能返回RateLimit-Remaining：时间窗口中剩余的呼叫数
7. 服务可能返回RateLimit-Reset：窗口重置的时间（以 UTC 纪元秒为单位）
8. 服务可能会根据需要返回其他服务特定的 RateLimit 标头，以获取更详细的信息或特定的限制或配额

#### 14.4.3. 过载的服务
当服务普遍过载时

1. 服务必须返回 503 代码
2. 服务必须返回描述细节的标准错误响应（请参阅 7.10.2），以便程序员可以进行适当的更改
3. 服务必须返回Retry-After标头，指示客户端在重试之前应等待多长时间
4. 在 503 情况下，服务不应返回RateLimit头

#### 14.4.4. 示例响应

```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
Retry-After: 5
RateLimit-Limit: 1000
RateLimit-Remaining: 0
RateLimit-Reset: 1538152773
{
  "error": {
    "code": "requestLimitExceeded",
    "message": "The caller has made too many requests in the time period.",
    "details": {
      "code": "RateLimit",
       "limit": "1000",
       "remaining": "0",
       "reset": "1538152773",
      }
    }
}
```

### 14.5. 调用者指南
调用者包括 API 的所有用户：工具、门户、其他服务，而不仅仅是用户客户端

1. 在重试请求之前，调用者必须等待 Retry-After 响应中指示的最短时间。
2. 调用者可以假设在接收到带有 Retry-After 标头的响应后请求是可重试的，而无需对请求进行任何更改。
3. 客户端应使用共享 SDK 和通用暂时性故障库来实现正确的行为

请参见： https://docs.microsoft.com/en-us/azure/architecture/best-practices/transient-faults

### 14.6. 处理忽略Retry-After标头的调用者
理想情况下，429 和 503 返回的成本非常低，即使是立即重试的客户也可以处理。
在这些情况下，如果可能，服务团队应努力联系或修复客户端。
如果是已知的合作伙伴，则应提交错误或事件。
在极端情况下，可能需要使用 DoS 风格的保护，例如阻止调用者。

## 15.通过webook推送通知
### 15.1. 范围
服务可以通过 Web Hooks实现推送通知。
本节介绍以下关键方案：

> 通过 HTTP 回调（通常称为 Web Hooks）将通知推送到可公开寻址的服务器。

之所以选择所提出的方法，是因为它简单，适用性广，并且服务订户的进入门槛低。
它旨在作为一组最低要求和作为其他功能的起点。

### 15.2. 原则
支持 Web Hook的服务的核心原则是：

1. 服务必须至少实现 poke/pull 模型。在 poke/pull 模型中，向客户端发送通知，然后客户端发送请求以获取自上次通知以来的当前状态或更改记录。此方法避免了消息排序、丢失消息和更改集的复杂性。 服务可能会添加更多数据以提供丰富的通知。
2. 服务必须实现challenge/response协议来配置回调 URL。
3. 服务应该有建议的过期时间，服务可以根据场景灵活变化。
4. 服务应允许引发成功通知的订阅永久存在，并且应容忍合理的中断时间。
5. Firehose 订阅必须仅通过 HTTPS 提供。服务应要求其他订阅类型为 HTTPS。有关更多详细信息，请参阅"安全性"部分。

### 15.3. 订阅类型
有两种订阅类型，服务可以同时实现这两种订阅类型，也可以不实现。
支持的订阅类型包括：

1. Firehose 订阅 – 为订阅应用程序手动创建订阅，通常在应用程序注册门户中。 任何用户已同意接收应用的活动通知都将发送到此单个订阅。
2. 按资源订阅 – 订阅应用程序使用代码在运行时以编程方式为某些用户特定的实体创建订阅。

支持这两种订阅类型的服务应为这两种类型提供差异化的开发人员体验：

1. Firehose – 服务不得要求开发人员创建代码，除非直接验证和响应通知。 服务必须为订阅管理提供管理 UI。 服务不应假定最终用户知道订阅，而只假定订阅应用程序的功能。
2. 按用户 – 服务必须为开发人员提供 API，以便将订阅作为其应用的一部分进行创建和管理，以及验证和响应通知。 服务可能希望最终用户了解订阅，并且必须允许最终用户吊销直接为响应用户操作而创建的订阅。

### 15.4. 调用序列
Firehose订阅的调用顺序必须遵循下图。
它显示应用程序和订阅的手动注册，然后最终用户使用服务的 API 之一。
在流程的这一部分，必须存储两个内容：

1. 该服务必须存储最终用户同意从此特定应用程序接收通知的行为（通常是后台使用 OAUTH 范围）。
2. 订阅应用程序必须存储最终用户的令牌，以便在收到更改通知后回调详细信息。

序列的最后一部分是通知流本身。

非规范性实现指南：服务中的资源发生更改，服务需要运行以下逻辑：

1. 确定有权访问资源的用户集，因此可以期望应用代表他们接收有关该资源的通知。
2. 查看哪些用户已同意接收通知以及来自哪些应用。
3. 查看哪些应用已注册Firehose订阅。
4. 加入 1、2、3 以生成必须发送到应用的具体通知集。

应该注意的是，用户同意行为和设置Firehose订阅的行为可以按任一顺序到达。
服务应发送通知，并按任一顺序处理设置。

![Firehose subscription setup][websequencediagram-firehose-subscription-setup]

对于按用户订阅，应用注册是手动或自动的。
按用户订阅的调用流必须遵循下图。
它显示了最终用户使用服务的 API 之一，并且必须存储相同的两个内容：

1. 该服务必须存储最终用户同意从此特定应用程序接收通知的行为（通常是后台使用 OAUTH 范围）。
2. 订阅应用程序必须存储最终用户的令牌，以便在收到更改通知后回调详细信息。

在这种情况下，订阅是使用订阅应用程序中的最终用户令牌以编程方式设置的。
应用程序必须将已注册订阅的 ID 与用户令牌一起存储。

非规范性实现指导：在序列的最后一部分，当服务中的数据项发生更改且服务需要运行以下逻辑时：

1. 通过资源找到与更改的数据相对应的订阅集。
2. 对于在应用 + 用户令牌下创建的订阅，使用订阅创建者的订阅 ID 和用户 ID 向每个订阅的应用发送通知。
- 对于使用仅应用令牌创建的订阅，检查更改数据的所有者或任何可以查看更改数据的用户是否已同意向应用程序发送通知，如果同意，则按用户 ID 向应用程序发送一组通知每个带有订阅 ID 的订阅。

  ![User subscription setup][websequencediagram-user-subscription-setup]

### 15.5. 验证订阅
当订阅以编程方式或通过管理 UI 门户响应更改时，需要保护订阅服务免受来自推送潜在大量通知流量的服务进行的恶意或意外调用。

对于所有订阅，无论是 firehose 还是按用户订阅，服务都必须在发送任何其他通知之前，通过门户 UI 或 API 请求发送验证请求作为创建或修改的一部分。

验证请求必须采用以下格式，向 _notificationUrl_ 发起 HTTP/HTTPS POST 请求。

```http
POST https://{notificationUrl}?validationToken={randomString}
ClientState: clientOriginatedOpaqueToken (if provided by client on subscription-creation)
Content-Length: 0
```

对于要设置的订阅，应用程序必须以 200 OK 响应此请求，并将 _validationToken_ 值作为唯一的实体正文。
请注意，如果 _notificationUrl_ 包含查询参数，则必须在 _validationToken_ 参数加  `&`。

如果任何质询请求在发送请求后 5 秒内未收到规定的响应，则服务必须返回错误，不得创建订阅，并且不得向 _notificationUrl_ 发送进一步的请求或通知。

服务可能会对 URL 所有权执行其他验证。

### 15.6. 接收通知
服务应发送通知以响应服务数据更改，这些更改不包含更改本身的详细信息，但包含足够的信息，以便订阅应用程序正确响应以下过程：

1. 应用程序必须标识要用于回调的正确缓存 OAuth 令牌
2. 应用程序可以查找任何以前的增量令牌以获取相关的更改范围
3. 应用程序必须确定要调用的 URL，以便对服务的新状态（可能是增量查询）执行相关查询。

提供将中继给最终用户的通知的服务可以选择向通知数据包添加更多详细信息，以减少其服务上的传入呼叫负载。
此类服务必须明确，通知不保证交付，并且可能是有损或无序的。

通知可以聚合并分批发送。
应用程序必须准备好在单个推送通知中接收多个事件。

该服务必须将所有 Web Hook 数据通知作为 POST 请求发送。

服务必须允许通知超时 30 秒。
如果发生超时或应用程序以 5xx 响应进行响应，则服务应以指数重试通知进行缓解。
所有其他响应都将被忽略。

该服务不得遵循 301/302 重定向请求。

#### 15.6.1. 通知载荷
通知载荷的基本格式是事件列表，每个事件都包含其引用资源已更改的订阅的 ID、更改类型、应消耗的资源来标识更改的确切细节以及足够的标识信息，以查找调用该资源所需的令牌。

对于firehose订阅，具体示例可能如下所示：

```json
{
  "value": [
    {
      "subscriptionId": "32b8cbd6174ab18b",
      "resource": "https://api.contoso.com/v1.0/users/user@contoso.com/files?$delta",
      "userId" : "<User GUID>",
      "tenantId" : "<Tenant Id>"
    }
  ]
}
```

对于按用户订阅，具体示例可能如下所示：

```json
{
  "value": [
    {
      "subscriptionId": "32b8cbd6174ab183",
      "clientState": "clientOriginatedOpaqueToken",
      "expirationDateTime": "2016-02-04T11:23Z",
      "resource": "https://api.contoso.com/v1.0/users/user@contoso.com/files/$delta",
      "userId" : "<User GUID>",
      "tenantId" : "<Tenant Id>"
    },
    {
      "subscriptionId": "97b391179fa22",
      "clientState ": "clientOriginatedOpaqueToken",
      "expirationDateTime": "2016-02-04T11:23Z",
      "resource": "https://api.contoso.com/v1.0/users/user@contoso.com/files/$delta",
      "userId" : "<User GUID>",
      "tenantId" : "<Tenant Id>"
    }
  ]
}
```

以下是 JSON 载荷的详细说明。

通知项由一个顶级对象组成，该对象包含一个事件数组，每个事件都标识了发送此通知的订阅。

字段 | 描述
----- | --------------------------------------------------------------------------------------------------
value | 自上次通知以来在订阅范围内引发的事件数组。

事件数组的每一项都包含以下属性：

字段              | 描述
------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
subscriptionId     | 发送此通知的订阅的 ID。<br/>服务必须提供 *subscriptionId* 字段。
clientState        |如果服务是在创建订阅时提供的，则必须提供 *clientState* 字段。
expirationDateTime |如果订阅有 *expirationDateTime* 字段，则服务必须提供 *expirationDateTime*。
resource           | 服务必须提供资源字段。订阅应用程序必须将此 URL 视为不透明。 对于更丰富的通知，它可能被隐式包含资源 URL 的消息内容所包含以避免重复。<br/>如果服务将此数据作为更详细的数据包的一部分提供，则无需重复。
userId             | 服务必须为用户范围的资源提供此字段。 对于用户范围的资源，应使用用户的唯一标识符。<br/>在一组特定用户之间共享资源的情况下，必须发送多个通知，传递每个用户的唯一标识符。<br/>对于租户范围的资源，应使用订阅的用户标识。
tenantId           | 希望支持跨租户请求的服务应提供此字段。提供租户范围数据的通知的服务必须发送此字段。

### 15.7. 以编程方式管理订阅
对于按用户订阅，必须提供 API 来创建和管理订阅。
API 必须至少支持此处所述的操作。

#### 15.7.1. 创建订阅
客户端通过对订阅资源发出 POST 请求来创建订阅。
订阅命名空间是客户端通过 POST 操作定义的。

```
https://api.contoso.com/apiVersion/$subscriptions
```

POST 请求包含要创建的单个订阅对象。
该订阅对象具有以下属性：

属性名称   | 必填 | 注释
--------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------
resource        | 是      | 要监视的资源路径。
通知网址 | 是      | 目标 Web 挂钩 URL。
clientState     | 否       | 在所有通知上传递回客户端的不透明字符串。调用者可以选择使用它来提供标记机制。

如果订阅已成功创建，则服务必须响应状态码 201 CREATED 并至少包含以下属性的正文：

属性名称      | 必填 | 注释
------------------ | -------- | -------------------------------------------------------------------------------------------
id                 | 是      | 新订阅的唯一 ID，以后可用于更新/删除订阅。
expirationDateTime | 否       | 使用现有的 Microsoft REST API 指南定义的时间格式。

订阅的创建应该是幂等的。
范围限定为身份验证令牌的属性组合提供了唯一性约束。

下面是使用User + Application从文件订阅通知的示例请求：

```http
POST https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1
Authorization: Bearer {UserPrincipalBearerToken}

{
  "resource": "http://api.service.com/v1.0/files/file1.txt",
  "notificationUrl": "https://contoso.com/myCallbacks",
  "clientState": "clientOriginatedOpaqueToken"
}
```

服务应以最少的响应格式响应此类消息，如下所示：

```json
{
  "id": "32b8cbd6174ab18b",
  "expirationDateTime": "2016-02-04T11:23Z"
}
```

下面是使用仅限Application的示例，其中应用程序正在监视其授权的所有文件：

```http
POST https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1
Authorization: Bearer {ApplicationPrincipalBearerToken}

{
  "resource": "All.Files",
  "notificationUrl": "https://contoso.com/myCallbacks",
  "clientState": "clientOriginatedOpaqueToken"
}
```

服务应以最少的响应格式响应此类消息，如下所示：

```json
{
  "id": "8cbd6174abb391179",
  "expirationDateTime": "2016-02-04T11:23Z"
}
```

#### 15.7.2. 更新订阅
服务可能支持修改订阅。
若要更新现有订阅的属性，客户端使用 PATCH 请求提供需要更改的 ID 和属性。
省略的属性将保留其值。
若要删除属性，请为其分配 JSON null 值。

与创建一样，订阅是单独管理的。

以下请求更改现有订阅的通知 URL：

```http
PATCH https://api.contoso.com/files/v1.0/$subscriptions/{id} HTTP 1.1
Authorization: Bearer {UserPrincipalBearerToken}

{
  "notificationUrl": "https://contoso.com/myNewCallback"
}
```

如果 PATCH 请求包含新的 _notificationUrl_ ，则服务器必须如上所述对其执行验证。
如果新 URL 无法验证，则服务必须使 PATCH 请求失败，并使订阅保持其先前的状态。

该服务必须返回一个空的正文和 `204 No Content` 来表示成功处理PATCH请求。

如果PATCH失败，服务必须返回错误正文和状态代码。

操作必须以原子方式成功或失败。

#### 15.7.3. 删除订阅
服务必须支持删除订阅。
可以通过对订阅资源发出 DELETE 请求来删除现有订阅：

```http
DELETE https://api.contoso.com/files/v1.0/$subscriptions/{id} HTTP 1.1
Authorization: Bearer {UserPrincipalBearerToken}
```

与更新一样，服务必须返回 `204 No Content` 才能成功删除，或者返回错误正文和状态代码以指示失败。

#### 15.7.4. 枚举订阅
若要获取活动订阅的列表，客户端使用User + Application或对Application-Only bearer token对订阅资源发出 GET 请求：

```http
GET https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1
Authorization: Bearer {UserPrincipalBearerToken}
```

该服务必须使用User + Application令牌返回如下所示的格式：

```json
{
  "value": [
    {
      "id": "32b8cbd6174ab18b",
      "resource": " http://api.contoso.com/v1.0/files/file1.txt",
      "notificationUrl": "https://contoso.com/myCallbacks",
      "clientState": "clientOriginatedOpaqueToken",
      "expirationDateTime": "2016-02-04T11:23Z"
    }
  ]
}
```

可以使用Application-Only principal bearer token返回的示例：

```json
{
  "value": [
    {
      "id": "6174ab18bfa22",
      "resource": "All.Files ",
      "notificationUrl": "https://contoso.com/myCallbacks",
      "clientState": "clientOriginatedOpaqueToken",
      "expirationDateTime": "2016-02-04T11:23Z"
    }
  ]
}
```

### 15.8. 安全
所有服务 URL 都必须是 HTTPS（即，所有入站调用都必须是 HTTPS）。处理 Web Hooks 的服务必须接受 HTTPS。

我们建议允许客户端定义的 Web Hook 回调 URL 的服务不应通过 HTTP 传输数据。
这是因为信息可能会通过客户端、网络、服务器日志和其他机制无意中暴露。

但是，由于客户端终结点或软件限制，在某些情况下无法遵循上述建议。
因此，服务可能允许 HTTP 的 Web Hook URL。

此外，允许客户端定义的 HTTP Web Hook 回调 URL 的服务应符合工程领导层指定的隐私政策。
这通常包括建议客户端首选 SSL 连接并遵守特殊预防措施，以确保正确处理日志和其他服务数据收集。

例如，服务可能不希望要求开发人员生成证书才能载入。
服务可能仅在测试帐户上启用此功能。

## 16. 不支持的请求
RESTful API 客户端可能会请求当前不支持的功能。
RESTful API 必须响应与本节一致的有效但不受支持的请求。

### 16.1. 基本指南
RESTful API 通常会选择限制客户端可以执行的功能。
例如，审核系统允许创建记录，但不允许修改或删除记录。
类似地，某些 API 会公开集合，但需要或以其他方式限制筛选和排序条件，或者可能不支持客户端驱动的分页。

### 16.2. 功能允许列表
如果服务不支持以下任何 API 功能，则当调用者请求该功能时，必须提供错误响应。
这些功能包括：
- 集合中的键寻址，例如： `https://api.contoso.com/v1.0/people/user1@contoso.com`
- 按属性值筛选集合，例如： `https://api.contoso.com/v1.0/people?$filter=name eq 'david'`
- 按范围筛选集合，例如： `http://api.contoso.com/v1.0/people?$filter=hireDate ge 2014-01-01 and hireDate le 2014-12-31`
- 通过$top和$skip进行客户端驱动的分页，例如： `http://api.contoso.com/v1.0/people?$top=5&$skip=2`
- 按$orderBy排序，例如： `https://api.contoso.com/v1.0/people?$orderBy=name desc`
- 提供$delta令牌，例如： `https://api.contoso.com/v1.0/people?$delta`

#### 16.2.1. 错误响应
如果调用者请求在功能允许列表中找到的不受支持的功能，则服务必须提供错误响应。
错误响应必须是来自 4xx 系列的 HTTP 状态代码，表示无法完成请求。
除非更具体的错误状态适合给定的请求，否则服务应返回"400 Bad Request"和符合 Microsoft REST API 指南中提供的错误响应指南的错误载荷。
服务应在响应消息中包含足够的详细信息，以便开发人员准确确定请求的哪一部分不受支持。

例：

```http
GET https://api.contoso.com/v1.0/people?$orderBy=name HTTP/1.1
Accept: application/json
```

```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": {
    "code": "ErrorUnsupportedOrderBy",
    "message": "Ordering by name is not supported."
  }
}
```

## 17. 命名准则
### 17.1. 方法
命名策略应帮助开发人员发现功能，而不必经常参考文档。
使用通用模式和标准约定极大地帮助开发人员正确猜测通用属性名称和含义。
服务应使用详细的命名模式，并且不应使用首字母缩略词以外的缩写，这些首字母缩略词是API所表示的域中的主要表达方式（例如Url）。

### 17.2. 大小写
- 首字母缩略词应遵循大小写约定，就好像它们是常规单词（例如Url）一样。
- 所有标识符（包括命名空间、实体类型、实体集、属性、操作、函数和枚举值）都应使用lowerCamelCase。
- HTTP 标头是例外，应使用大写连字符术语的标准 HTTP 约定。

### 17.3. 要避免的名称
某些名称在 API 域中重载，以至于它们失去了所有意义，或者与域中的其他常见用法发生冲突，而这些用法在使用 REST API 时是无法避免的，例如 OAUTH。
服务不应使用以下名称：
- Context
- Scope
- Resource

### 17.4. 形成混合名称
- 服务应避免使用诸如"a"，"the"，"of"之类的冠词，除非需要传达含义。
    - 例如，不应使用aUser, theAccount, countOfBooks等名称，而应首选user, account, bookCount。
- 服务应向属性名称添加类型，否则会导致数据表示方式的歧义或导致服务不使用通用属性名称。
- 向属性名称添加类型时，服务必须在末尾添加类型，例如 createdDateTime。

### 17.5. 身份属性
- 服务必须对身份属性使用字符串类型。
- 对于 OData 服务，服务必须使用 OData @id属性来表示资源的规范标识符。
- 服务可以使用简单的"id"属性来表示资源的本地或旧主键值。
- 服务应使用后缀有"Id"的关系的名称来表示另一个资源的外键，例如 subscriptionId。
    - 此属性的内容应为引用资源的规范 ID。

### 17.6. 日期和时间属性

- 对于同时需要日期和时间的属性，服务必须使用后缀"DateTime"。
- 对于仅需要日期信息而不指定时间的属性，服务必须使用后缀"Date"，例如 birthDate。
- 对于仅需要时间信息而不指定日期的属性，服务必须使用后缀"Time"，例如 appointmentStartTime。

### 17.7. 名称属性
- 对于通常向用户显示的资源的整体名称，服务必须使用属性名称"displayName"。
- 服务可以使用其他常见的命名属性，例如givenName, surname, signInName。

### 17.8. 集合和计数
- 服务必须使用正确的英语将集合命名为复数名词或复数名词短语。
- 服务可以使用简化英语来表示不常用的复数名词。
    - 例如，可以使用 schemas 代替 schemata。
- 服务必须使用带有“Count”后缀的名词或名词短语来命名资源计数。

### 17.9. 常用属性名称
如果服务具有属性，其数据与以下名称匹配，则服务必须使用此表中的名称。
此表将随着服务添加更常用的术语而增长。
添加此类术语的服务所有者应建议对本文档进行添加。

| |
|------------- |
attendees     |
body          |
createdDateTime |
childCount    |
children      |
contentUrl    |
country       |
createdBy     |
displayName   |
errorUrl      |
eTag          |
event         |
expirationDateTime |
givenName     |
jobTitle      |
kind          |
id            |
lastModifiedDateTime |
location      |
memberOf      |
message       |
name          |
owner         |
people        |
person        |
postalCode    |
photo         |
preferredLanguage |
properties    |
signInName    |
surname       |
tags          |
userPrincipalName |
webUrl        |

## 18. 附录
### 18.1. 序列图注释
本文档中的所有序列图均使用 [WebSequenceDiagrams.com](https://www.websequencediagrams.com/)生成。要生成它们，请将以下文本粘贴到 web 工具中。

#### 18.1.1. 推送通知，每个用户流

```
=== Begin Text ===
note over Developer, Automation, App Server:
     An App Developer like MovieMaker
     Wants to integrate with primary service like Dropbox
end note
note over DB Portal, DB App Registration, DB Notifications, DB Auth, DB Service: The primary service like Dropbox
note over Client: The end users' browser or installed app

note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Manual App Registration


Developer <--> DB Portal : Login into Portal, App Registration UX
DB Portal -> +DB App Registration: App Name etc.
note over DB App Registration: Confirm Portal Access Token

DB App Registration -> -DB Portal: App ID
DB Portal <--> App Server: Developer copies App ID

note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Manual Notification Registration

Developer <--> DB Portal: webhook registration UX
DB Portal -> +DB Notifications: Register: App Server webhook URL, Scope, App ID
Note over DB Notifications : Confirm Portal Access Token
DB Notifications -> -DB Portal: notification ID
DB Portal --> App Server : Developer may copy notification ID


note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Client Authorization

Client -> +App Server : Request access to DB protected information
App Server -> -Client : Redirect to DB Authorization endpoint with authorization request
Client -> +DB Auth : Redirected authorization request
Client <--> DB Auth : Authorization UX
DB Auth -> -Client : Redirect back to App Server with code
Client -> +App Server : Redirect request back to access server with access code
App Server -> +DB Auth : Request tokens with access code
note right of DB Service: Cache that this User ID provided access to App ID
DB Auth -> -App Server : Response with access, refresh, and ID tokens
note right of App Server : Cache tokens by user ID
App Server -> -Client : Return information to client

note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Notification Flow

Client <--> DB Service: Changes to user data - typical via interacting with App Server via Client
DB Service -> App Server : Notification with notification ID and user ID
App Server -> +DB Service : Request changed information with cached access tokens and "since" token
note over DB Service: Confirm User Access Token
DB Service -> -App Server : Response with data and new "since" token
note right of App Server: Update status and cache new "since" token
=== End Text ===
```

#### 18.1.2. 推送通知、firehose 流

```
=== Begin Text ===
note over Developer, Automation, App Server:
     An App Developer like MovieMaker
     Wants to integrate with primary service like Dropbox
end note
note over DB Portal, DB App Registration, DB Notifications, DB Auth, DB Service: The primary service like Dropbox
note over Client: The end users' browser or installed app

note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : App Registration

alt Automated app registration
   Developer <--> Automation: Configure
   Automation -> +DB App Registration: App Name etc.
   note over DB App Registration: Confirm App Access Token
   DB App Registration -> -Automation: App ID, App Secret
   Automation --> App Server : Embed App ID, App Secret
else Manual app registration
   Developer <--> DB Portal : Login into Portal, App Registration UX
   DB Portal -> +DB App Registration: App Name etc.
   note over DB App Registration: Confirm Portal Access Token

   DB App Registration -> -DB Portal: App ID
   DB Portal <--> App Server: Developer copies App ID
end

note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Client Authorization

Client -> +App Server : Request access to DB protected information
App Server -> -Client : Redirect to DB Authorization endpoint with authorization request
Client -> +DB Auth : Redirected authorization request
Client <--> DB Auth : Authorization UX
DB Auth -> -Client : Redirect back to App Server with code
Client -> +App Server : Redirect request back to access server with access code
App Server -> +DB Auth : Request tokens with access code
note right of DB Service: Cache that this User ID provided access to App ID
DB Auth -> -App Server : Response with access, refresh, and ID tokens
note right of App Server : Cache tokens by user ID
App Server -> -Client : Return information to client



note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Notification Registration

App Server->+DB Notifications: Register: App server webhook URL, Scope, App ID
note over DB Notifications : Confirm User Access Token
DB Notifications -> -App Server: notification ID
note right of App Server : Cache the Notification ID and User Access Token



note over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Notification Flow

Client <--> DB Service: Changes to user data - typical via interacting with App Server via Client
DB Service -> App Server : Notification with notification ID and user ID
App Server -> +DB Service : Request changed information with cached access tokens and "since" token
note over DB Service: Confirm User Access Token
DB Service -> -App Server : Response with data and new "since" token
note right of App Server: Update status and cache new "since" token



=== End Text ===
```
[fielding]: https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
[IANA-headers]: https://www.iana.org/assignments/message-headers/message-headers.xhtml
[rfc-2119]: https://tools.ietf.org/html/rfc2119
[rfc7231-7-1-1-1]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1
[rfc-7230-3-1-1]: https://tools.ietf.org/html/rfc7230#section-3.1.1
[rfc-7231]: https://tools.ietf.org/html/rfc7231
[rest-in-practice]: https://www.amazon.com/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829/
[rest-on-wikipedia]: https://en.wikipedia.org/wiki/Representational_state_transfer
[rfc-5789]: https://tools.ietf.org/html/rfc5789
[rfc-5988]: https://tools.ietf.org/html/rfc5988
[rfc-3339]: https://tools.ietf.org/html/rfc3339
[rfc-5322-3-3]: https://tools.ietf.org/html/rfc5322#section-3.3
[cors-preflight]: https://www.w3.org/TR/cors/#resource-preflight-requests
[rfc-3864]: https://tools.ietf.org/html/rfc3864
[odata-json-annotations]: https://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html#_Instance_Annotations
[cors]: https://www.w3.org/TR/access-control/
[cors-user-credentials]: https://www.w3.org/TR/access-control/#user-credentials
[cors-simple-headers]: https://www.w3.org/TR/access-control/#simple-header
[rfc-4627]: https://tools.ietf.org/html/rfc4627
[iso-8601]: https://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15
[clr-time]: https://msdn.microsoft.com/en-us/library/System.DateTime(v=vs.110).aspx
[ecmascript-time]: https://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1
[ole-date]: https://docs.microsoft.com/en-us/windows/desktop/api/oleauto/nf-oleauto-varianttimetosystemtime
[ticks-time]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724290(v=vs.85).aspx
[unix-time]: https://msdn.microsoft.com/en-us/library/1f4c8f33.aspx
[windows-time]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724290(v=vs.85).aspx
[excel-time]: https://support.microsoft.com/kb/214326?wa=wsignin1.0
[wikipedia-iso8601-durations]: https://en.wikipedia.org/wiki/ISO_8601#Durations
[wikipedia-iso8601-intervals]: https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
[wikipedia-iso8601-repeatingintervals]: https://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals
[principle-of-least-astonishment]: https://en.wikipedia.org/wiki/Principle_of_least_astonishment
[odata-breaking-changes]: https://docs.oasis-open.org/odata/odata/v4.0/errata02/os/complete/part1-protocol/odata-v4.0-errata02-os-part1-protocol-complete.html#_Toc406398209
[websequencediagram-firehose-subscription-setup]: https://www.websequencediagrams.com/cgi-bin/cdraw?lz=bm90ZSBvdmVyIERldmVsb3BlciwgQXV0b21hdGlvbiwgQXBwIFNlcnZlcjogCiAgICAgQW4AEAUAJwkgbGlrZSBNb3ZpZU1ha2VyACAGV2FudHMgdG8gaW50ZWdyYXRlIHdpdGggcHJpbWFyeSBzZXJ2aWNlADcGRHJvcGJveAplbmQgbm90ZQoAgQwLQiBQb3J0YWwsIERCAIEJBVJlZ2lzdHIAgRkHREIgTm90aWZpYwCBLAVzACEGdXRoACsFUwBgBjogVGhlAF0eAIF_CkNsaWVudAAtBmVuZCB1c2VycycgYnJvd3NlciBvciBpbnN0YWxsZWQgYXBwCgCBIQwAgiQgAIFABQCBIS8AgQoGIDogTWFudWFsAIFzEQoKCgCDAgo8LS0-AIIqCiA6IExvZ2luIGludG8Agj8JAII1ECBVWCAKACoKLT4gKwCCWBM6AIQGBU5hbWUgZXRjLgCDFQ4AGxJDb25maXJtAIEBCEFjY2VzcyBUb2tlbgoKAIM3EyAtPiAtAINkCQBnBklEAIEMCwCBVQUAhQIMAIR3CmNvcGllcwArCACCIHAAhHMMAIMKDwCDABg6IHdlYmhvb2sgcgCCeg4AgnUSAIVQDToAhXYHZXIAgwgGAIcTBgBECVVSTCwgU2NvcGUAhzIGSUQKTgCGPQwAhhwNIACDBh4AHhEAgxEPbgCBagwAgxwNAIMaDiAAgx0MbWF5IGNvcHkALREAhVtqAIZHB0F1dGhvcml6AIY7BwCGXQctPiArAIEuDVJlcXVlc3QgYQCFOQZ0byBEQiBwcm90ZWN0ZWQgaW5mb3IAiiQGCgCDBQstPiAtAIctCVJlZGlyZWN0ADYHAGwNIGVuZHBvaW50AIoWBmEADw1yAHYGAIEQDACJVAcASwtlZAAYHgCICAgAMAcAcA4AhGoGAE0FAIEdFmJhY2sgdG8AhF8NaXRoIGNvZGUAghoaaQCBagcAgToHAD0JAII-B3MAPgsAglEHAEsFAIIzDgCBXw0Agn8GdG9rZW5zACcSAI0_BXJpZ2h0IG9mAItpDUNhY2hlIHRoYXQgdGhpcyBVc2VyIElEIHByb3ZpZGVkAINNCwCIZgoAggcJAIN7D3Nwb25zAI0_BwCECgYsIHJlZnJlc2gsIGFuZCBJRACBHAcAgQMPAIYADQCBDAcAgUUGYnkAjFkFIElEAIQkG3R1cm4AhF4MIHRvIGMAjR8FAIwRagCJVw1GbG93AIYqCQCMaQgAgmoKaGFuZ2UAj3YFAIFXBWRhdGEgLSB0eXBpY2FsIHZpYQCQDgVyYWN0aW5nAJAPBgCJQQt2aWEAjnsHCgCPNgogAIhDEACKZw0AkFMFAIkBDwCDDAUAgkYWKwBNCwCHWApjAIEyBQCHRg0AhWUHYWNoAIQeDACEfwVhbmQgInNpbmNlIgCFEQYAkSQOAIR3CgCNfwcAhHQFAIpQEACBUgsAhFAcAII8BWFuZCBuZXcAYRQAhFUTOiBVcGRhdGUgc3RhdHUAgSkGAIFDBQAxEwoKCg&s=mscgen
[websequencediagram-user-subscription-setup]: https://www.websequencediagrams.com/cgi-bin/cdraw?lz=bm90ZSBvdmVyIERldmVsb3BlciwgQXV0b21hdGlvbiwgQXBwIFNlcnZlcjogCiAgICAgQW4AEAUAJwkgbGlrZSBNb3ZpZU1ha2VyACAGV2FudHMgdG8gaW50ZWdyYXRlIHdpdGggcHJpbWFyeSBzZXJ2aWNlADcGRHJvcGJveAplbmQgbm90ZQoAgQwLQiBQb3J0YWwsIERCAIEJBVJlZ2lzdHIAgRkHREIgTm90aWZpYwCBLAVzACEGdXRoACsFUwBgBjogVGhlAF0eAIF_CkNsaWVudAAtBmVuZCB1c2VycycgYnJvd3NlciBvciBpbnN0YWxsZWQgYXBwCgCBIQwAgiQgAIFABQCBIS8AgQoGIDoAgWwRCgphbHQAgyUIAIEHBiByABQMICAAgxsLPC0tPgCDTws6IENvbmZpZ3VyZQogIACDaAsgLT4gKwCCWBMAegZOYW1lIGV0Yy4AhAgFAIMaDQAfEgBdBXJtAIQ_BUFjY2VzcyBUb2tlAIETBgCDOxIgLT4gLQCBFgxBcHAgSUQAhHwIY3JldACBGxAtPgCFFgsgOiBFbWJlZAAkFGVsc2UgTWFudWFsAIIEJACEbQkgOiBMb2dpbiBpbnRvAIUBCQCBKRFVWACGGAUALQoAgh8mAIIZKwCBCAcAgjoNAIIsHACGLwkAgj8IAIESDgCECAYAh1ELAIdFCmNvcGllcwAuCGVuZACEeGoAhWQHQXV0aG9yaXoAhV8HAIV6By0-ICsAg2ANUmVxdWVzdCBhAIRVBnRvIERCIHByb3RlY3RlZCBpbmZvcgCJQQYKAIQaCy0-IC0AhkoJUmVkaXJlY3QANgcAbA0gZW5kcG9pbnQAiTMGYQAPDXIAdgYAgRAMAIhxBwBLC2VkABgeAIRjCAAwB0EAcQxVWAoASQgAgRwWYmFjayB0bwCFdAwAilwFY29kZQCCGRppAIFpBwCBOQcAPQkAgj0HcwA-CwCCUAcASwUAgjIOAIFeDQCCfgZ0b2tlbnMAJxIAjFsFcmlnaHQgb2YAiwUNQ2FjaGUgdGhhdCB0aGlzIFVzZXIgSUQgcHJvdmlkZWQAg0wLAIU6BwCCBAwAg3oPc3BvbnMAjFsHAIQJBiwgcmVmcmVzaCwgYW5kIElEAIEcBwCBAw8AiDENAIEMBwCBRQZieQCLdQUgSUQAhCMbdHVybgCEXQwgdG8gYwCMOwUKCgCLL2oAjXUMAIwTDwCPNQotPisAjhwQOgCORQdlcgCMVwYAg3YIZWJob29rIFVSTCwgU2NvcGUAkAEGSUQAjwoOAI5rDSAAi2UKAINFBQCLYw0AHBEAgzUOOiBuAIE2DABgCACDCB1oZQCBaQ5JRACDYwUAahIAghB4RmxvdwCJMwkAjE0IAIV0CmhhbmdlAJIcBQCEYQVkYXRhIC0gdHlwaWNhbCB2aWEAkjQFcmFjdGluZwCSNQYAjV8LdmlhAJEhBwoAkVwKIACNfhAAhAsNAJJ5BQCCWQ8AhhYFAIVQFisATQsAimEKYwCBMgUAik8NAIhvB2FjaACHKAwAiAkFYW5kICJzaW5jZSIAiBsGAJNKDgCIAQoAhB0cAIFSCwCHWhwAgjwFYW5kIG5ldwBhFACHXxM6IFVwZGF0ZSBzdGF0dQCBKQYAgUMFADETCgoK&s=mscgen